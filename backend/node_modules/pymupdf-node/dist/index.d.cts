import { PyCallable, PyProxy } from 'pyodide/ffi';

declare const origin: unique symbol;

declare class PyMuPDFBase {
    private static readonly PREFIX_MOUNTED_PATH;
    constructor();
    private static checkPyodide;
    protected static fromGlobals<T = PyCallable>(name: string): T;
    protected static fromModule<T = PyCallable>(module: string, name: string): T;
    protected static getAttribute<T>(obj: PyProxy, name: string): T;
    protected static setAttribute<T>(obj: PyProxy, name: string, value: T): void;
    protected static isPyProxy(value: unknown): value is PyProxy;
    protected static toJs<T>(value: unknown): T;
    protected static mountDirectory(directory: string): void;
    protected static getMountDirectory(directory: string): string;
    private static isMountDirectory;
    private static isDirExists;
    private static mkdirRecursive;
    protected static toPyBytes(buffer: ArrayBufferLike): PyProxy;
    protected static getOriginStaticMember<T>(module: string, name: string): T;
    protected static executeOriginStaticMethod<T>(module: string, name: string, hasKwargs?: boolean, ...args: unknown[]): T;
}
declare abstract class PyMuPDFClassBase extends PyMuPDFBase {
    private _origin;
    constructor(args: unknown[]);
    get [origin](): PyProxy;
    protected getOriginMember<T>(name: string): T;
    protected setOriginMember<T>(name: string, value: T): void;
    protected executeOriginMethod<T>(name: string, hasKwargs?: boolean, ...args: unknown[]): T;
    protected abstract buildOrigin(...args: unknown[]): PyProxy;
}

declare const enum Member$v {
    n = "n",
    name = "name"
}
declare class Colorspace extends PyMuPDFClassBase {
    constructor(n: number);
    constructor(colorspace: Colorspace);
    constructor(ref: PyProxy);
    protected buildOrigin(n: number): PyProxy;
    protected buildOrigin(colorspace: Colorspace): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$v.n](): number;
    get [Member$v.name](): string;
}

declare abstract class Geometry<T> {
    abstract abs(): number;
    abstract add(item: unknown): T;
    abstract subject(item: unknown): T;
    abstract multiply(item: unknown): T;
    abstract divide(item: unknown): T;
    abstract equals(item: unknown): boolean;
    abstract negative(): T;
    abstract positive(): T;
}
declare abstract class GeometryWithInverse<T> extends Geometry<T> {
    abstract inverse(): T;
}
declare abstract class GeometryWithContains<T> extends Geometry<T> {
    abstract contains(item: unknown): boolean;
}

declare const enum Member$u {
    a = "a",
    b = "b",
    c = "c",
    d = "d",
    e = "e",
    f = "f",
    is_rectilinear = "is_rectilinear"
}
declare const enum Method$p {
    norm = "norm",
    prerotate = "prerotate",
    prescale = "prescale",
    preshear = "preshear",
    pretranslate = "pretranslate",
    concat = "concat",
    invert = "invert",
    abs = "abs",
    add = "add",
    subject = "subject",
    multiply = "multiply",
    divide = "divide",
    equals = "equals",
    negative = "negative",
    positive = "positive",
    inverse = "inverse"
}
declare class Matrix extends PyMuPDFClassBase implements GeometryWithInverse<Matrix> {
    constructor();
    constructor(zoom_x: number, zoom_y: number);
    constructor(shear_x: number, shear_y: number, scale: number);
    constructor(a: number, b: number, c: number, d: number, e: number, f: number);
    constructor(degree: number);
    constructor(matrix: Matrix);
    constructor(sequence: PyMuPDFType.MatrixLike);
    constructor(proxy: PyProxy);
    protected buildOrigin(): PyProxy;
    protected buildOrigin(zoom_x: number, zoom_y: number): PyProxy;
    protected buildOrigin(shear_x: number, shear_y: number, scale: number): PyProxy;
    protected buildOrigin(a: number, b: number, c: number, d: number, e: number, f: number): PyProxy;
    protected buildOrigin(degree: number): PyProxy;
    protected buildOrigin(matrix: Matrix): PyProxy;
    protected buildOrigin(sequence: PyMuPDFType.MatrixLike): PyProxy;
    protected buildOrigin(proxy: PyProxy): PyProxy;
    get [Member$u.a](): number;
    get [Member$u.b](): number;
    get [Member$u.c](): number;
    get [Member$u.d](): number;
    get [Member$u.e](): number;
    get [Member$u.f](): number;
    get [Member$u.is_rectilinear](): boolean;
    [Method$p.norm](): number;
    [Method$p.prerotate](deg: number): Matrix;
    [Method$p.prescale](sx: number, sy: number): Matrix;
    [Method$p.preshear](sx: number, sy: number): Matrix;
    [Method$p.pretranslate](tx: number, ty: number): Matrix;
    [Method$p.concat](m1: Matrix | PyMuPDFType.MatrixLike, m2: Matrix | PyMuPDFType.MatrixLike): Matrix;
    [Method$p.invert](m?: Matrix | PyMuPDFType.MatrixLike | null): number;
    [Method$p.abs](): number;
    [Method$p.add](item: PyMuPDFType.MatrixLike | Matrix | number): Matrix;
    [Method$p.subject](item: PyMuPDFType.MatrixLike | Matrix | number): Matrix;
    [Method$p.multiply](item: PyMuPDFType.MatrixLike | Matrix | number): Matrix;
    [Method$p.divide](item: PyMuPDFType.MatrixLike | Matrix | number): Matrix;
    [Method$p.equals](item: PyMuPDFType.MatrixLike | Matrix): boolean;
    [Method$p.negative](): Matrix;
    [Method$p.positive](): Matrix;
    [Method$p.inverse](): Matrix;
}

declare const enum Member$t {
    unit = "unit",
    abs_unit = "abs_unit",
    x = "x",
    y = "y"
}
declare const enum Method$o {
    distance_to = "distance_to",
    norm = "norm",
    transform = "transform",
    abs = "abs",
    add = "add",
    subject = "subject",
    multiply = "multiply",
    divide = "divide",
    equals = "equals",
    negative = "negative",
    positive = "positive"
}
declare class Point extends PyMuPDFClassBase implements Geometry<Point> {
    constructor();
    constructor(x: number, y: number);
    constructor(point: Point);
    constructor(sequence: PyMuPDFType.PointLike);
    constructor(ref: PyProxy);
    protected buildOrigin(): PyProxy;
    protected buildOrigin(x: number, y: number): PyProxy;
    protected buildOrigin(sequence: PyMuPDFType.PointLike): PyProxy;
    protected buildOrigin(point: Point): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$t.x](): number;
    get [Member$t.y](): number;
    get [Member$t.abs_unit](): Point;
    get [Member$t.unit](): Point;
    [Method$o.distance_to](x: PyMuPDFType.PointLike | Point | PyMuPDFType.RectLike | Rect, unit?: string): number;
    [Method$o.norm](): number;
    [Method$o.transform](m: PyMuPDFType.MatrixLike | Matrix): Point;
    [Method$o.abs](): number;
    [Method$o.add](item: PyMuPDFType.PointLike | Point | number): Point;
    [Method$o.subject](item: PyMuPDFType.PointLike | Point | number): Point;
    [Method$o.multiply](item: PyMuPDFType.PointLike | PyMuPDFType.MatrixLike | Point | Matrix | number): Point;
    [Method$o.divide](item: PyMuPDFType.MatrixLike | Matrix | number): Point;
    [Method$o.equals](item: PyMuPDFType.PointLike | Point): boolean;
    [Method$o.negative](): Point;
    [Method$o.positive](): Point;
}

declare const enum Member$s {
    ul = "ul",
    ur = "ur",
    ll = "ll",
    lr = "lr",
    is_convex = "is_convex",
    is_empty = "is_empty",
    is_rectangular = "is_rectangular",
    rect = "rect",
    width = "width",
    height = "height"
}
declare const enum Method$n {
    transform = "transform",
    morph = "morph",
    abs = "abs",
    add = "add",
    subject = "subject",
    multiply = "multiply",
    divide = "divide",
    equals = "equals",
    negative = "negative",
    positive = "positive",
    contains = "contains"
}
declare class Quad extends PyMuPDFClassBase implements GeometryWithContains<Quad> {
    constructor();
    constructor(ul: PyMuPDFType.PointLike, ur: PyMuPDFType.PointLike, ll: PyMuPDFType.PointLike, lr: PyMuPDFType.PointLike);
    constructor(quad: Quad);
    constructor(sequence: PyMuPDFType.QuadLike);
    constructor(ref: PyProxy);
    protected buildOrigin(): PyProxy;
    protected buildOrigin(ul: PyMuPDFType.PointLike, ur: PyMuPDFType.PointLike, ll: PyMuPDFType.PointLike, lr: PyMuPDFType.PointLike): PyProxy;
    protected buildOrigin(quad: Quad): PyProxy;
    protected buildOrigin(sequence: PyMuPDFType.QuadLike): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$s.ul](): Point;
    get [Member$s.ur](): Point;
    get [Member$s.ll](): Point;
    get [Member$s.lr](): Point;
    get [Member$s.is_convex](): boolean;
    get [Member$s.is_empty](): boolean;
    get [Member$s.is_rectangular](): boolean;
    get [Member$s.rect](): Rect;
    get [Member$s.width](): number;
    get [Member$s.height](): number;
    [Method$n.transform](matrix: PyMuPDFType.MatrixLike | Matrix): Quad;
    [Method$n.morph](fixpoint: PyMuPDFType.PointLike | Point, matrix: PyMuPDFType.MatrixLike | Matrix): Quad;
    [Method$n.abs](): number;
    [Method$n.add](item: PyMuPDFType.QuadLike | Quad | number): Quad;
    [Method$n.subject](item: PyMuPDFType.QuadLike | Quad | number): Quad;
    [Method$n.multiply](item: PyMuPDFType.MatrixLike | Matrix): Quad;
    [Method$n.divide](item: PyMuPDFType.MatrixLike | Matrix): Quad;
    [Method$n.equals](item: PyMuPDFType.QuadLike | Quad): boolean;
    [Method$n.negative](): Quad;
    [Method$n.positive](): Quad;
    [Method$n.contains](item: PyMuPDFType.QuadLike | PyMuPDFType.RectLike | PyMuPDFType.PointLike | Quad | Rect | Point): boolean;
}

declare const enum Member$r {
    bottom_left = "bottom_left",
    bottom_right = "bottom_right",
    height = "height",
    is_empty = "is_empty",
    is_infinite = "is_infinite",
    rect = "rect",
    top_left = "top_left",
    top_right = "top_right",
    quad = "quad",
    width = "width",
    x0 = "x0",
    x1 = "x1",
    y0 = "y0",
    y1 = "y1"
}
declare const enum Method$m {
    contains = "contains",
    get_area = "get_area",
    intersect = "intersect",
    intersects = "intersects",
    morph = "morph",
    torect = "torect",
    norm = "norm",
    normalize = "normalize",
    include_point = "include_point",
    include_rect = "include_rect",
    transform = "transform",
    abs = "abs",
    add = "add",
    subject = "subject",
    multiply = "multiply",
    divide = "divide",
    equals = "equals",
    negative = "negative",
    positive = "positive"
}
declare class IRect extends PyMuPDFClassBase implements Geometry<IRect> {
    constructor();
    constructor(x0: number, y0: number, x1: number, y1: number);
    constructor(top_left: PyMuPDFType.PointLike | Point, bottom_right: PyMuPDFType.PointLike | Point);
    constructor(top_left: PyMuPDFType.PointLike | Point, x1: number, y1: number);
    constructor(x0: number, y0: number, bottom_right: PyMuPDFType.PointLike | Point);
    constructor(irect: IRect);
    constructor(sequence: PyMuPDFType.IRectLike);
    constructor(ref: PyProxy);
    protected buildOrigin(): PyProxy;
    protected buildOrigin(x0: number, y0: number, x1: number, y1: number): PyProxy;
    protected buildOrigin(top_left: PyMuPDFType.PointLike | Point, bottom_right: PyMuPDFType.PointLike | Point): PyProxy;
    protected buildOrigin(top_left: PyMuPDFType.PointLike | Point, x1: number, y1: number): PyProxy;
    protected buildOrigin(x0: number, y0: number, bottom_right: PyMuPDFType.PointLike | Point): PyProxy;
    protected buildOrigin(irect: IRect): PyProxy;
    protected buildOrigin(sequence: PyMuPDFType.IRectLike): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$r.bottom_left](): Point;
    get [Member$r.bottom_right](): Point;
    get [Member$r.height](): number;
    get [Member$r.is_empty](): boolean;
    get [Member$r.is_infinite](): boolean;
    get [Member$r.rect](): Rect;
    get [Member$r.top_left](): Point;
    get [Member$r.top_right](): Point;
    get [Member$r.quad](): Quad;
    get [Member$r.width](): number;
    get [Member$r.x0](): number;
    get [Member$r.y0](): number;
    get [Member$r.x1](): number;
    get [Member$r.y1](): number;
    [Method$m.contains](x: IRect | Rect | Point | PyMuPDFType.RectLike | PyMuPDFType.PointLike): boolean;
    [Method$m.get_area](unit?: string): number;
    [Method$m.intersect](r: Rect | PyMuPDFType.RectLike): IRect;
    [Method$m.intersects](x: IRect | Rect | Point | PyMuPDFType.RectLike | PyMuPDFType.PointLike): boolean;
    [Method$m.morph](fixpoint: Point | PyMuPDFType.PointLike, matrix: Matrix | PyMuPDFType.MatrixLike): Quad;
    [Method$m.torect](r: Rect | PyMuPDFType.RectLike): Matrix;
    [Method$m.norm](): number;
    [Method$m.normalize](): IRect;
    [Method$m.include_point](p: Point | PyMuPDFType.PointLike): IRect;
    [Method$m.include_rect](r: Rect | PyMuPDFType.RectLike): IRect;
    [Method$m.transform](m: Matrix | PyMuPDFType.MatrixLike): IRect;
    [Method$m.abs](): number;
    [Method$m.add](item: PyMuPDFType.IRectLike | IRect | number): IRect;
    [Method$m.subject](item: PyMuPDFType.IRectLike | IRect | number): IRect;
    [Method$m.multiply](item: PyMuPDFType.MatrixLike | Matrix | number): IRect;
    [Method$m.divide](item: PyMuPDFType.MatrixLike | Matrix | number): IRect;
    [Method$m.equals](item: PyMuPDFType.IRectLike | IRect): boolean;
    [Method$m.negative](): IRect;
    [Method$m.positive](): IRect;
}

declare const enum Member$q {
    rect = "rect"
}
declare const enum Method$l {
    extractText = "extractText",
    extractTEXT = "extractTEXT",
    extractBLOCKS = "extractBLOCKS",
    extractWORDS = "extractWORDS",
    extractHTML = "extractHTML",
    extractXHTML = "extractXHTML",
    extractXML = "extractXML",
    extractDICT = "extractDICT",
    extractJSON = "extractJSON",
    extractRAWDICT = "extractRAWDICT",
    extractRAWJSON = "extractRAWJSON",
    search = "search"
}
declare class TextPage extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$q.rect](): Rect;
    [Method$l.extractTEXT](sort?: boolean): string;
    [Method$l.extractText](sort?: boolean): string;
    [Method$l.extractBLOCKS](): PyMuPDFType.Block[];
    [Method$l.extractWORDS](delimiters?: string): PyMuPDFType.Word[];
    [Method$l.extractHTML](): string;
    [Method$l.extractXHTML](): string;
    [Method$l.extractXML](): string;
    [Method$l.extractDICT](sort?: boolean): PyMuPDFType.PageDict;
    [Method$l.extractJSON](sort?: boolean): string;
    [Method$l.extractRAWDICT](sort?: boolean): PyMuPDFType.PageDict<PyMuPDFType.SpanRawDict>;
    [Method$l.extractRAWJSON](sort?: boolean): string;
    [Method$l.search](needle: string): Quad[];
    [Method$l.search](needle: string, quad: true): Quad[];
    [Method$l.search](needle: string, quad: false): Rect[];
}

declare const enum Member$p {
    blendmode = "blendmode",
    border = "border",
    colors = "colors",
    file_info = "file_info",
    flags = "flags",
    has_popup = "has_popup",
    irt_xref = "irt_xref",
    info = "info",
    is_open = "is_open",
    line_ends = "line_ends",
    next = "next",
    opacity = "opacity",
    parent = "parent",
    popup_rect = "popup_rect",
    popup_xref = "popup_xref",
    rect = "rect",
    type = "type",
    vertices = "vertices",
    xref = "xref"
}
declare const enum Method$k {
    delete_responses = "delete_responses",
    get_file = "get_file",
    get_oc = "get_oc",
    get_pixmap = "get_pixmap",
    get_sound = "get_sound",
    get_text = "get_text",
    get_textbox = "get_textbox",
    get_textpage = "get_textpage",
    set_apn_bbox = "set_apn_bbox",
    set_apn_matrix = "set_apn_matrix",
    set_border = "set_border",
    set_blendmode = "set_blendmode",
    set_colors = "set_colors",
    set_flags = "set_flags",
    set_info = "set_info",
    set_irt_xref = "set_irt_xref",
    set_language = "set_language",
    set_line_ends = "set_line_ends",
    set_name = "set_name",
    set_oc = "set_oc",
    set_opacity = "set_opacity",
    set_open = "set_open",
    set_popup = "set_popup",
    set_rect = "set_rect",
    set_rotation = "set_rotation",
    update = "update",
    update_file = "update_file"
}
declare class Annot extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$p.blendmode](): string | null;
    get [Member$p.border](): PyMuPDFType.Annot.Border;
    get [Member$p.colors](): PyMuPDFType.Annot.Colors;
    get [Member$p.file_info](): PyMuPDFType.Annot.FileInfo;
    get [Member$p.flags](): number;
    get [Member$p.has_popup](): boolean;
    get [Member$p.irt_xref](): number;
    get [Member$p.info](): PyMuPDFType.Annot.Info;
    get [Member$p.is_open](): boolean;
    get [Member$p.line_ends](): [number, number];
    get [Member$p.next](): Annot;
    get [Member$p.opacity](): number;
    get [Member$p.parent](): Annot;
    get [Member$p.popup_rect](): Rect;
    get [Member$p.popup_xref](): number;
    get [Member$p.rect](): Rect;
    get [Member$p.type](): PyMuPDFType.Annot.Type;
    get [Member$p.vertices](): PyMuPDFType.PointLike[];
    get [Member$p.xref](): number;
    [Method$k.delete_responses](): void;
    [Method$k.get_file](): Uint8Array;
    [Method$k.get_oc](): number;
    [Method$k.get_pixmap](options?: PyMuPDFType.Annot.GetPrixMapOptions): Pixmap;
    [Method$k.get_sound](): PyMuPDFType.Annot.GetSoundResult | null;
    [Method$k.get_text](option: 'text', clip: PyMuPDFType.RectLike | Rect, flags: number): string;
    [Method$k.get_text](option: 'blocks', clip: PyMuPDFType.RectLike | Rect, flags: number): PyMuPDFType.Block[];
    [Method$k.get_text](option: 'words', clip: PyMuPDFType.RectLike | Rect, flags: number): PyMuPDFType.Word[];
    [Method$k.get_text](option: 'dict', clip: PyMuPDFType.RectLike | Rect, flags: number): PyMuPDFType.PageDict;
    [Method$k.get_text](option: 'json', clip: PyMuPDFType.RectLike | Rect, flags: number): string;
    [Method$k.get_text](option: 'rawdict', clip: PyMuPDFType.RectLike | Rect, flags: number): PyMuPDFType.PageDict<PyMuPDFType.SpanRawDict>;
    [Method$k.get_textbox](rect: PyMuPDFType.RectLike | Rect): string;
    [Method$k.get_textpage](clip?: PyMuPDFType.RectLike | Rect, flags?: number): TextPage;
    [Method$k.set_apn_bbox](bbox: PyMuPDFType.RectLike | Rect): void;
    [Method$k.set_apn_matrix](matrix: PyMuPDFType.MatrixLike | Matrix): void;
    [Method$k.set_border](border?: Partial<PyMuPDFType.Annot.Border>, width?: number, style?: string, dashes?: number[], clouds?: number): void;
    [Method$k.set_blendmode](blendmode: string): void;
    [Method$k.set_colors](colors?: PyMuPDFType.Annot.Colors, stroke?: PyMuPDFType.ColorSequence, fill?: PyMuPDFType.ColorSequence): void;
    [Method$k.set_flags](flags: number): void;
    [Method$k.set_info](info?: Partial<Omit<PyMuPDFType.Annot.Info, 'id'>>, content?: string, title?: string, creationDate?: string, modDate?: string, subject?: string): void;
    [Method$k.set_irt_xref](xref: number): void;
    [Method$k.set_language](language?: number): void;
    [Method$k.set_line_ends](start: number, end: number): void;
    [Method$k.set_name](name: string): void;
    [Method$k.set_oc](xref: number): void;
    [Method$k.set_opacity](opacity: number): void;
    [Method$k.set_open](open: boolean): void;
    [Method$k.set_popup](popup: PyMuPDFType.RectLike | Rect): void;
    [Method$k.set_rect](rect: PyMuPDFType.RectLike | Rect): void;
    [Method$k.set_rotation](deg: number): void;
    [Method$k.update](options?: PyMuPDFType.Annot.UpdateOptions): boolean;
    [Method$k.update_file](buffer?: ArrayBuffer, filename?: string, ufilename?: string, desc?: string): void;
}

declare const enum Member$o {
    bbox = "bbox",
    cells = "cells"
}
declare class TableRow extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$o.bbox](): PyMuPDFType.RectLike;
    get [Member$o.cells](): PyMuPDFType.RectLike[];
}

declare const enum Member$n {
    bbox = "bbox",
    cells = "cells",
    names = "names",
    external = "external"
}
declare class TableHeader extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$n.bbox](): Rect;
    get [Member$n.cells](): PyMuPDFType.RectLike[];
    get [Member$n.names](): string[];
    get [Member$n.external](): boolean;
}

declare const enum Member$m {
    bbox = "bbox",
    cells = "cells",
    rows = "rows",
    row_count = "row_count",
    col_count = "col_count",
    header = "header"
}
declare const enum Method$j {
    to_markdown = "to_markdown"
}
declare class Table extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$m.bbox](): PyMuPDFType.RectLike;
    get [Member$m.cells](): PyMuPDFType.RectLike[];
    get [Member$m.rows](): TableRow[];
    get [Member$m.row_count](): number;
    get [Member$m.col_count](): number;
    get [Member$m.header](): TableHeader;
    [Method$j.to_markdown](clean?: boolean, fill_empty?: boolean): string;
}

declare const enum Member$l {
    tables = "tables"
}
declare class TableFinder extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$l.tables](): Table[];
}

declare const enum Member$k {
    next = "next",
    border_color = "border_color",
    border_style = "border_style",
    border_width = "border_width",
    border_dashes = "border_dashes",
    choice_values = "choice_values",
    field_name = "field_name",
    field_label = "field_label",
    field_value = "field_value",
    field_flags = "field_flags",
    field_type = "field_type",
    field_type_string = "field_type_string",
    fill_color = "fill_color",
    button_caption = "button_caption",
    is_signed = "is_signed",
    rect = "rect",
    text_color = "text_color",
    text_font = "text_font",
    text_fontsize = "text_fontsize",
    text_maxlen = "text_maxlen",
    xref = "xref",
    script = "script",
    script_stroke = "script_stroke",
    script_format = "script_format",
    script_change = "script_change",
    script_calc = "script_calc",
    script_blur = "script_blur",
    script_focus = "script_focus"
}
declare const enum Method$i {
    button_states = "button_states",
    on_state = "on_state",
    update = "update",
    reset = "reset"
}
declare class Widget extends PyMuPDFClassBase {
    constructor();
    constructor(ref: PyProxy);
    protected buildOrigin(): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$k.next](): Widget | null;
    get [Member$k.border_color](): PyMuPDFType.ColorSequence | null;
    set [Member$k.border_color](border_color: PyMuPDFType.ColorSequence);
    get [Member$k.border_style](): string;
    set [Member$k.border_style](style: string);
    get [Member$k.border_width](): number;
    set [Member$k.border_width](width: number);
    get [Member$k.border_dashes](): number[] | null;
    set [Member$k.border_dashes](dashes: number[]);
    get [Member$k.choice_values](): string[] | null;
    set [Member$k.choice_values](values: string[]);
    get [Member$k.field_name](): string;
    set [Member$k.field_name](name: string);
    get [Member$k.field_label](): string | null;
    set [Member$k.field_label](label: string);
    get [Member$k.field_value](): PyMuPDFType.Widget.FieldValue;
    set [Member$k.field_value](value: PyMuPDFType.Widget.FieldValue);
    get [Member$k.field_flags](): number;
    set [Member$k.field_flags](flags: number);
    get [Member$k.field_type](): number;
    set [Member$k.field_type](type: number);
    get [Member$k.field_type_string](): string;
    get [Member$k.fill_color](): PyMuPDFType.ColorSequence | null;
    set [Member$k.fill_color](color: PyMuPDFType.ColorSequence);
    get [Member$k.button_caption](): string | null;
    get [Member$k.is_signed](): boolean | null;
    get [Member$k.rect](): Rect | null;
    set [Member$k.rect](rect: Rect);
    get [Member$k.text_color](): PyMuPDFType.ColorSequence;
    set [Member$k.text_color](color: PyMuPDFType.ColorSequence);
    get [Member$k.text_font](): string;
    set [Member$k.text_font](font: string);
    get [Member$k.text_fontsize](): number;
    set [Member$k.text_fontsize](fontsize: number);
    get [Member$k.text_maxlen](): number;
    set [Member$k.text_maxlen](maxlen: number);
    get [Member$k.xref](): number;
    get [Member$k.script](): string | null;
    set [Member$k.script](script: string);
    get [Member$k.script_stroke](): string | null;
    get [Member$k.script_format](): string | null;
    get [Member$k.script_change](): string | null;
    get [Member$k.script_calc](): string | null;
    get [Member$k.script_blur](): string | null;
    get [Member$k.script_focus](): string | null;
    [Method$i.button_states](): PyMuPDFType.Widget.ButtonStatesResult | null;
    [Method$i.on_state](): string | true | null;
    [Method$i.update](sync_flags?: boolean): unknown;
    [Method$i.reset](): void;
}

declare const enum Member$j {
    border = "border",
    colors = "colors",
    dest = "dest",
    is_external = "is_external",
    flags = "flags",
    next = "next",
    rect = "rect",
    uri = "uri",
    xref = "xref"
}
declare const enum Method$h {
    set_border = "set_border",
    set_colors = "set_colors",
    set_flags = "set_flags"
}
declare class Link extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$j.border](): Omit<PyMuPDFType.Annot.Border, 'clouds'>;
    get [Member$j.colors](): PyMuPDFType.Annot.Colors;
    get [Member$j.dest](): string;
    get [Member$j.is_external](): boolean;
    get [Member$j.flags](): number;
    get [Member$j.next](): Link;
    get [Member$j.rect](): Rect;
    get [Member$j.uri](): string;
    get [Member$j.xref](): number;
    [Method$h.set_border](border?: Partial<Omit<PyMuPDFType.Annot.Border, 'clouds'>>, width?: number, style?: string, dashes?: number[]): Omit<PyMuPDFType.Annot.Border, 'clouds'>;
    [Method$h.set_colors](colors?: Partial<PyMuPDFType.Annot.Colors>, stroke?: PyMuPDFType.ColorSequence): void;
    [Method$h.set_flags](flags: number): void;
}

declare const enum Member$i {
    doc = "doc",
    draw_cont = "draw_cont",
    height = "height",
    last_point = "last_point",
    page = "page",
    rect = "rect",
    text_cont = "text_cont",
    totalcont = "totalcont",
    width = "width"
}
declare const enum Method$g {
    commit = "commit",
    draw_bezier = "draw_bezier",
    draw_circle = "draw_circle",
    draw_curve = "draw_curve",
    draw_line = "draw_line",
    draw_oval = "draw_oval",
    draw_polyline = "draw_polyline",
    draw_quad = "draw_quad",
    draw_rect = "draw_rect",
    draw_sector = "draw_sector",
    draw_squiggle = "draw_squiggle",
    draw_zigzag = "draw_zigzag",
    finish = "finish",
    horizontal_angle = "horizontal_angle",
    insert_text = "insert_text",
    insert_textbox = "insert_textbox",
    updateRect = "updateRect"
}
declare class Shape extends PyMuPDFClassBase {
    constructor(page: Page);
    constructor(ref: PyProxy);
    protected buildOrigin(page: Page): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$i.doc](): Document;
    get [Member$i.draw_cont](): string;
    get [Member$i.height](): number;
    get [Member$i.last_point](): Point;
    get [Member$i.page](): Page;
    get [Member$i.rect](): Rect;
    get [Member$i.text_cont](): string;
    get [Member$i.totalcont](): string;
    get [Member$i.width](): number;
    [Method$g.commit](overlay?: boolean): void;
    [Method$g.draw_bezier](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point, p3: PyMuPDFType.PointLike | Point, p4: PyMuPDFType.PointLike | Point): Point;
    [Method$g.draw_circle](center: PyMuPDFType.PointLike | Point, radius: number): Point;
    [Method$g.draw_curve](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point, p3: PyMuPDFType.PointLike | Point): Point;
    [Method$g.draw_line](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point): Point;
    [Method$g.draw_oval](tetra: PyMuPDFType.RectLike | PyMuPDFType.QuadLike | Rect | Quad): Point;
    [Method$g.draw_polyline](points: (PyMuPDFType.PointLike | Point)[]): Point;
    [Method$g.draw_quad](quad: PyMuPDFType.QuadLike | Quad): Point;
    [Method$g.draw_rect](rect: PyMuPDFType.RectLike | Rect): Point;
    [Method$g.draw_sector](center: PyMuPDFType.PointLike | Point, point: PyMuPDFType.PointLike | Point, beta: number, fullSector?: boolean): Point;
    [Method$g.draw_squiggle](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point, breadth?: number): Point;
    [Method$g.draw_zigzag](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point, breadth?: number): Point;
    [Method$g.finish](options?: PyMuPDFType.Shape.FinishOptions): void;
    static [Method$g.horizontal_angle](C: PyMuPDFType.PointLike | Point, P: PyMuPDFType.PointLike | Point): number;
    [Method$g.insert_text](point: PyMuPDFType.PointLike | Point, buffer: string | string[], options?: PyMuPDFType.Shape.InsertTextOptions): number;
    [Method$g.insert_textbox](rect: PyMuPDFType.RectLike | Rect, buffer: string | string[], options: PyMuPDFType.Shape.InsertTextOptions & {
        expandtabs?: number;
        miter_limit?: number;
        overlay?: boolean;
        align?: number;
    }): number;
    [Method$g.updateRect](x: PyMuPDFType.PointLike | PyMuPDFType.RectLike | Point | Rect): void;
}

declare const enum Member$h {
    entry_list = "entry_list"
}
declare const enum Method$f {
    add = "add",
    has_entry = "has_entry",
    read_entry = "read_entry"
}
declare class Archive extends PyMuPDFClassBase {
    constructor();
    constructor(content: PyMuPDFType.Archive.Content | Archive | (PyMuPDFType.Archive.Content | Archive)[]);
    constructor(content: PyMuPDFType.Archive.Content | Archive | (PyMuPDFType.Archive.Content | Archive)[], path: string);
    constructor(ref: PyProxy);
    protected buildOrigin(): PyProxy;
    protected buildOrigin(content: PyMuPDFType.Archive.Content | Archive | (PyMuPDFType.Archive.Content | Archive)[]): PyProxy;
    protected buildOrigin(content: PyMuPDFType.Archive.Content | Archive | (PyMuPDFType.Archive.Content | Archive)[], path: string): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    private convertContent;
    get [Member$h.entry_list](): PyMuPDFType.Archive.Entry[];
    [Method$f.add](content: PyMuPDFType.Archive.Content | Archive | (PyMuPDFType.Archive.Content | Archive)[], path?: string): void;
    [Method$f.has_entry](name: string): boolean;
    [Method$f.read_entry](name: string): Uint8Array;
}

declare const enum Member$g {
    ascender = "ascender",
    descender = "descender",
    bbox = "bbox",
    buffer = "buffer",
    flags = "flags",
    glyph_count = "glyph_count",
    name = "name",
    is_bold = "is_bold",
    is_monospaced = "is_monospaced",
    is_serif = "is_serif",
    is_italic = "is_italic"
}
declare const enum Method$e {
    char_lengths = "char_lengths",
    glyph_advance = "glyph_advance",
    glyph_bbox = "glyph_bbox",
    glyph_name_to_unicode = "glyph_name_to_unicode",
    has_glyph = "has_glyph",
    text_length = "text_length",
    unicode_to_glyph_name = "unicode_to_glyph_name",
    valid_codepoints = "valid_codepoints"
}
declare class Font extends PyMuPDFClassBase {
    constructor();
    constructor(options: PyMuPDFType.Font.ConstructorOptions);
    constructor(ref: PyProxy);
    protected buildOrigin(): PyProxy;
    protected buildOrigin(options: PyMuPDFType.Font.ConstructorOptions): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$g.ascender](): number;
    get [Member$g.descender](): number;
    get [Member$g.bbox](): Rect;
    get [Member$g.buffer](): Uint8Array;
    get [Member$g.flags](): PyMuPDFType.Font.Flags;
    get [Member$g.glyph_count](): number;
    get [Member$g.name](): string;
    get [Member$g.is_bold](): boolean;
    get [Member$g.is_monospaced](): boolean;
    get [Member$g.is_serif](): boolean;
    get [Member$g.is_italic](): boolean;
    [Method$e.char_lengths](text: string, options?: PyMuPDFType.Font.BaseOptions): number[];
    [Method$e.glyph_advance](chr_: number, options?: Omit<PyMuPDFType.Font.BaseOptions, 'fontsize'>): number;
    [Method$e.glyph_bbox](char: number, options?: Omit<PyMuPDFType.Font.BaseOptions, 'fontsize' | 'wmode'>): Rect;
    [Method$e.glyph_name_to_unicode](name: string): number;
    [Method$e.has_glyph](chr: number, options?: Omit<PyMuPDFType.Font.BaseOptions, 'fontsize' | 'wmode'> & {
        fallback?: boolean;
    }): number;
    [Method$e.text_length](text: string, options?: PyMuPDFType.Font.BaseOptions): number;
    [Method$e.unicode_to_glyph_name](ch: number): string;
    [Method$e.valid_codepoints](): number[];
}

declare const enum Member$f {
    color = "color",
    last_point = "last_point",
    opacity = "opacity",
    rect = "rect",
    text_rect = "text_rect"
}
declare const enum Method$d {
    append = "append",
    appendv = "appendv",
    clean_rtl = "clean_rtl",
    fill_textbox = "fill_textbox",
    write_text = "write_text"
}
declare class TextWriter extends PyMuPDFClassBase {
    constructor(page_rect: PyMuPDFType.RectLike | Rect);
    constructor(page_rect: PyMuPDFType.RectLike | Rect, opacity: number);
    constructor(page_rect: PyMuPDFType.RectLike | Rect, opacity: number, color: PyMuPDFType.ColorSequence | null);
    constructor(ref: PyProxy);
    protected buildOrigin(page_rect: PyMuPDFType.RectLike | Rect): PyProxy;
    protected buildOrigin(page_rect: PyMuPDFType.RectLike | Rect, opacity: number): PyProxy;
    protected buildOrigin(page_rect: PyMuPDFType.RectLike | Rect, opacity: number, color: PyMuPDFType.ColorSequence | null): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$f.color](): PyMuPDFType.ColorSequence;
    get [Member$f.last_point](): Point;
    get [Member$f.opacity](): number;
    get [Member$f.rect](): Rect;
    get [Member$f.text_rect](): Rect;
    [Method$d.append](pos: PyMuPDFType.PointLike | Point, text: string, options?: PyMuPDFType.TextWriter.AppendOptions): [text_rect: Rect, last_point: Point];
    [Method$d.appendv](pos: PyMuPDFType.PointLike | Point, text: string, options?: Omit<PyMuPDFType.TextWriter.AppendOptions, 'right_to_left'>): [text_rect: Rect, last_point: Point];
    [Method$d.clean_rtl](text: string): string;
    [Method$d.fill_textbox](rect: PyMuPDFType.RectLike | Rect, text: string | string[], options?: PyMuPDFType.TextWriter.FillTextboxOptions & {
        font?: string | Font;
    }): PyMuPDFType.TextWriter.FillTextboxOptions[];
    [Method$d.write_text](page: Page, options?: PyMuPDFType.TextWriter.WriteTextOptions): void;
}

declare const enum Member$e {
    cropbox_position = "cropbox_position",
    cropbox = "cropbox",
    artbox = "artbox",
    bleedbox = "bleedbox",
    trimbox = "trimbox",
    derotation_matrix = "derotation_matrix",
    first_annot = "first_annot",
    first_link = "first_link",
    first_widget = "first_widget",
    mediabox_size = "mediabox_size",
    mediabox = "mediabox",
    number = "number",
    parent = "parent",
    rect = "rect",
    rotation_matrix = "rotation_matrix",
    rotation = "rotation",
    transformation_matrix = "transformation_matrix",
    xref = "xref"
}
declare const enum Method$c {
    add_caret_annot = "add_caret_annot",
    add_circle_annot = "add_circle_annot",
    add_file_annot = "add_file_annot",
    add_freetext_annot = "add_freetext_annot",
    add_highlight_annot = "add_highlight_annot",
    add_ink_annot = "add_ink_annot",
    add_line_annot = "add_line_annot",
    add_polygon_annot = "add_polygon_annot",
    add_polyline_annot = "add_polyline_annot",
    add_rect_annot = "add_rect_annot",
    add_redact_annot = "add_redact_annot",
    add_squiggly_annot = "add_squiggly_annot",
    add_stamp_annot = "add_stamp_annot",
    add_strikeout_annot = "add_strikeout_annot",
    add_text_annot = "add_text_annot",
    add_underline_annot = "add_underline_annot",
    add_widget = "add_widget",
    annot_names = "annot_names",
    annot_xrefs = "annot_xrefs",
    annots = "annots",
    apply_redactions = "apply_redactions",
    bound = "bound",
    clean_contents = "clean_contents",
    cluster_drawings = "cluster_drawings",
    delete_annot = "delete_annot",
    delete_image = "delete_image",
    delete_link = "delete_link",
    delete_widget = "delete_widget",
    draw_bezier = "draw_bezier",
    draw_circle = "draw_circle",
    draw_curve = "draw_curve",
    draw_line = "draw_line",
    draw_oval = "draw_oval",
    draw_polyline = "draw_polyline",
    draw_quad = "draw_quad",
    draw_rect = "draw_rect",
    draw_sector = "draw_sector",
    draw_squiggle = "draw_squiggle",
    draw_zigzag = "draw_zigzag",
    extend_textpage = "extend_textpage",
    find_tables = "find_tables",
    get_bboxlog = "get_bboxlog",
    get_cdrawings = "get_cdrawings",
    get_contents = "get_contents",
    get_drawings = "get_drawings",
    get_displaylist = "get_displaylist",
    get_fonts = "get_fonts",
    get_image_bbox = "get_image_bbox",
    get_image_info = "get_image_info",
    get_image_rects = "get_image_rects",
    get_images = "get_images",
    get_label = "get_label",
    get_links = "get_links",
    get_oc_items = "get_oc_items",
    get_pixmap = "get_pixmap",
    get_svg_image = "get_svg_image",
    get_text = "get_text",
    get_text_blocks = "get_text_blocks",
    get_text_selection = "get_text_selection",
    get_text_words = "get_text_words",
    get_texttrace = "get_texttrace",
    get_textbox = "get_textbox",
    get_textpage = "get_textpage",
    get_xobjects = "get_xobjects",
    insert_font = "insert_font",
    insert_image = "insert_image",
    insert_link = "insert_link",
    insert_text = "insert_text",
    insert_htmlbox = "insert_htmlbox",
    insert_textbox = "insert_textbox",
    links = "links",
    load_annot = "load_annot",
    load_widget = "load_widget",
    load_links = "load_links",
    new_shape = "new_shape",
    read_contents = "read_contents",
    recolor = "recolor",
    refresh = "refresh",
    remove_rotation = "remove_rotation",
    replace_image = "replace_image",
    run = "run",
    search_for = "search_for",
    set_artbox = "set_artbox",
    set_bleedbox = "set_bleedbox",
    set_contents = "set_contents",
    set_cropbox = "set_cropbox",
    set_language = "set_language",
    set_mediabox = "set_mediabox",
    set_rotation = "set_rotation",
    set_trimbox = "set_trimbox",
    show_pdf_page = "show_pdf_page",
    update_link = "update_link",
    widgets = "widgets",
    wrap_contents = "wrap_contents",
    write_text = "write_text"
}
declare class Page extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$e.cropbox_position](): Point;
    get [Member$e.cropbox](): Rect;
    get [Member$e.artbox](): Rect;
    get [Member$e.bleedbox](): Rect;
    get [Member$e.trimbox](): Rect;
    get [Member$e.derotation_matrix](): Matrix;
    get [Member$e.first_annot](): Annot;
    get [Member$e.first_link](): Link;
    get [Member$e.first_widget](): Widget;
    get [Member$e.mediabox_size](): Point;
    get [Member$e.mediabox](): Rect;
    get [Member$e.number](): number;
    get [Member$e.parent](): Document$1;
    get [Member$e.rect](): Rect;
    get [Member$e.rotation_matrix](): Matrix;
    get [Member$e.rotation](): number;
    get [Member$e.transformation_matrix](): Matrix;
    get [Member$e.xref](): number;
    [Method$c.add_caret_annot](point: PyMuPDFType.PointLike | Point): Annot;
    [Method$c.add_circle_annot](rect: PyMuPDFType.RectLike | Rect): Annot;
    [Method$c.add_file_annot](point: PyMuPDFType.PointLike | Point, buffer_: ArrayBuffer, filename: string, options?: PyMuPDFType.Page.AddFileAnnotOptions): Annot;
    [Method$c.add_freetext_annot](rect: PyMuPDFType.RectLike | Rect, text: string, options?: PyMuPDFType.Page.AddFreetextAnnotOptions): Annot;
    [Method$c.add_highlight_annot](options: PyMuPDFType.Page.AddMarkdownAnnotOptions): Annot;
    [Method$c.add_ink_annot](points: (PyMuPDFType.PointLike | Point)[][]): Annot;
    [Method$c.add_line_annot](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point): Annot;
    [Method$c.add_polygon_annot](points: (PyMuPDFType.PointLike | Point)[]): Annot;
    [Method$c.add_polyline_annot](points: (PyMuPDFType.PointLike | Point)[]): Annot;
    [Method$c.add_rect_annot](rect: PyMuPDFType.RectLike | Rect): Annot;
    [Method$c.add_redact_annot](quad: PyMuPDFType.RectLike | PyMuPDFType.QuadLike | Rect | Quad, options?: PyMuPDFType.Page.AddRedactAnnotOptions): Annot;
    [Method$c.add_squiggly_annot](options: PyMuPDFType.Page.AddMarkdownAnnotOptions): Annot;
    [Method$c.add_stamp_annot](rect: PyMuPDFType.RectLike | Rect, stamp: number | string | ArrayBuffer): Annot;
    [Method$c.add_strikeout_annot](options: PyMuPDFType.Page.AddMarkdownAnnotOptions): Annot;
    [Method$c.add_text_annot](point: PyMuPDFType.PointLike | Point, text: string, icon?: string): Annot;
    [Method$c.add_underline_annot](options: PyMuPDFType.Page.AddMarkdownAnnotOptions): Annot;
    [Method$c.add_widget](widget: Widget): Widget;
    [Method$c.annot_names](): string;
    [Method$c.annot_xrefs](): PyMuPDFType.Page.AnnotXrefsResult[];
    [Method$c.annots](types?: number[]): Annot[];
    [Method$c.apply_redactions](options?: PyMuPDFType.Page.ApplyRedactionsOptions): boolean;
    [Method$c.bound](): Rect;
    [Method$c.clean_contents](sanitize?: number): void;
    [Method$c.cluster_drawings](options?: PyMuPDFType.Page.ClusterDrawings): Rect[];
    [Method$c.delete_annot](annot: Annot): Annot;
    [Method$c.delete_image](xref: number): void;
    [Method$c.delete_link](linkdict: PyMuPDFType.Link): void;
    [Method$c.delete_widget](widget: Widget): Widget;
    [Method$c.draw_bezier](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point, p3: PyMuPDFType.PointLike | Point, p4: PyMuPDFType.PointLike | Point, options?: PyMuPDFType.Page.DrawOptions): Point;
    [Method$c.draw_circle](center: PyMuPDFType.PointLike | Point, radius: number, options?: PyMuPDFType.Page.DrawOptions): Point;
    [Method$c.draw_curve](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point, p3: PyMuPDFType.PointLike | Point, options?: PyMuPDFType.Page.DrawOptions): Point;
    [Method$c.draw_line](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point, options?: PyMuPDFType.Page.DrawOptions): Point;
    [Method$c.draw_oval](rect: PyMuPDFType.RectLike | PyMuPDFType.QuadLike | Rect | Quad, options?: PyMuPDFType.Page.DrawOptions): Point;
    [Method$c.draw_polyline](points: (PyMuPDFType.PointLike | Point)[], options?: PyMuPDFType.Page.DrawOptions): Point;
    [Method$c.draw_quad](quad: PyMuPDFType.QuadLike | Quad, options?: PyMuPDFType.Page.DrawOptions): Point;
    [Method$c.draw_rect](rect: PyMuPDFType.RectLike | Rect, options?: PyMuPDFType.Page.DrawOptions): Point;
    [Method$c.draw_sector](center: PyMuPDFType.PointLike | Point, point: PyMuPDFType.PointLike | Point, beta: number, options: PyMuPDFType.Page.DrawOptions & {
        fullSector?: boolean;
    }): Point;
    [Method$c.draw_squiggle](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point, options?: PyMuPDFType.Page.DrawOptions & {
        breadth?: number;
    }): Point;
    [Method$c.draw_zigzag](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point, options: PyMuPDFType.Page.DrawOptions & {
        breadth?: number;
    }): Point;
    [Method$c.extend_textpage](tpage: TextPage, flags?: number, matrix?: PyMuPDFType.MatrixLike | Matrix): void;
    [Method$c.find_tables](options?: PyMuPDFType.Page.FindTablesOptions): TableFinder;
    [Method$c.get_bboxlog](layers?: boolean): PyMuPDFType.Page.Bboxlog[];
    [Method$c.get_cdrawings](): PyMuPDFType.Path[];
    [Method$c.get_cdrawings](extended: false): PyMuPDFType.Path[];
    [Method$c.get_cdrawings](extended: true): PyMuPDFType.ExtendPath[];
    [Method$c.get_contents](): number[];
    [Method$c.get_drawings](): PyMuPDFType.Path[];
    [Method$c.get_drawings](extended: false): PyMuPDFType.Path[];
    [Method$c.get_drawings](extended: true): PyMuPDFType.ExtendPath[];
    [Method$c.get_displaylist](annots?: boolean): DisplayList;
    [Method$c.get_fonts](): PyMuPDFType.Document.PageFontSimpleResult[];
    [Method$c.get_fonts](extended: false): PyMuPDFType.Document.PageFontSimpleResult[];
    [Method$c.get_fonts](extended: true): PyMuPDFType.Document.PageFontFullResult[];
    [Method$c.get_image_bbox](name: string | PyMuPDFType.Document.PageImageFullResult): Rect;
    [Method$c.get_image_bbox](name: string | PyMuPDFType.Document.PageImageFullResult, transfrom: false): Rect;
    [Method$c.get_image_bbox](name: string | PyMuPDFType.Document.PageImageFullResult, transfrom: true): Matrix;
    [Method$c.get_image_info](hashes?: boolean, xrefs?: boolean): PyMuPDFType.Image[];
    [Method$c.get_image_rects](name: string | PyMuPDFType.Document.PageImageFullResult): Rect[];
    [Method$c.get_image_rects](name: string | PyMuPDFType.Document.PageImageFullResult, transform: false): Rect[];
    [Method$c.get_image_rects](name: string | PyMuPDFType.Document.PageImageFullResult, transform: true): [Rect, Matrix][];
    [Method$c.get_images](): PyMuPDFType.Document.PageImageSimpleResult[];
    [Method$c.get_images](full: false): PyMuPDFType.Document.PageImageSimpleResult[];
    [Method$c.get_images](full: true): PyMuPDFType.Document.PageImageFullResult[];
    [Method$c.get_label](): string;
    [Method$c.get_links](): PyMuPDFType.Link[];
    [Method$c.get_oc_items](): PyMuPDFType.Page.OcItem[];
    [Method$c.get_pixmap](options?: PyMuPDFType.Document.GetPagePixmapOptions): Pixmap;
    [Method$c.get_svg_image](matrix?: PyMuPDFType.MatrixLike | Matrix, text_as_path?: boolean): string;
    [Method$c.get_text](): string;
    [Method$c.get_text](options: PyMuPDFType.Page.GetTextOptions & {
        option: 'text' | 'html' | 'xml' | 'xhtml' | 'rawjson' | 'json';
    }): string;
    [Method$c.get_text](options: PyMuPDFType.Page.GetTextOptions & {
        option: 'words';
    }): PyMuPDFType.Word[];
    [Method$c.get_text](options: PyMuPDFType.Page.GetTextOptions & {
        option: 'blocks';
    }): PyMuPDFType.Block[];
    [Method$c.get_text](options: PyMuPDFType.Page.GetTextOptions & {
        option: 'dict';
    }): PyMuPDFType.PageDict;
    [Method$c.get_text](options: PyMuPDFType.Page.GetTextOptions & {
        option: 'rawdict';
    }): PyMuPDFType.PageDict<PyMuPDFType.SpanRawDict>;
    [Method$c.get_text_blocks](options?: Omit<PyMuPDFType.Document.GetPageTextOptions, 'option'>): PyMuPDFType.Block[];
    [Method$c.get_text_selection](p1: PyMuPDFType.PointLike | Point, p2: PyMuPDFType.PointLike | Point, clip?: PyMuPDFType.RectLike | Rect, textpage?: TextPage): string;
    [Method$c.get_text_words](options?: PyMuPDFType.Page.GetTextOptions): PyMuPDFType.Word[];
    [Method$c.get_texttrace](): PyMuPDFType.Page.TextTraceSpan[];
    [Method$c.get_textbox](rect: PyMuPDFType.RectLike | Rect, textpage?: TextPage): string;
    [Method$c.get_textpage](clip?: PyMuPDFType.RectLike | Rect, flags?: number, matrix?: PyMuPDFType.MatrixLike | Matrix): TextPage;
    [Method$c.get_xobjects](): PyMuPDFType.Document.GetPageXObjectResult[];
    [Method$c.insert_font](options?: PyMuPDFType.Page.InsertFontOptions): number;
    [Method$c.insert_image](rect: PyMuPDFType.RectLike | Rect, options?: PyMuPDFType.Page.InsertImageOptions): unknown;
    [Method$c.insert_link](link: PyMuPDFType.Link): void;
    [Method$c.insert_text](point: PyMuPDFType.PointLike | Point, text: string | string[], options?: PyMuPDFType.Page.InsertTextOptions): number;
    [Method$c.insert_htmlbox](rect: PyMuPDFType.RectLike | Rect, text: string | string[], options?: PyMuPDFType.Page.InsertHtmlboxOptions & {
        archive?: Archive;
    }): PyMuPDFType.Page.InsertHtmlBoxResult;
    [Method$c.insert_textbox](rect: PyMuPDFType.RectLike | Rect, buffer: string | string[], options?: PyMuPDFType.Page.InsertTextboxOptions): number;
    [Method$c.links](kinds?: number[]): PyMuPDFType.Link[];
    [Method$c.load_annot](ident: string | number): Annot;
    [Method$c.load_widget](xref: number): Widget;
    [Method$c.load_links](): Link;
    [Method$c.new_shape](): Shape;
    [Method$c.read_contents](): Uint8Array;
    [Method$c.recolor](components?: number): void;
    [Method$c.refresh](): void;
    [Method$c.remove_rotation](): Matrix;
    [Method$c.replace_image](xref: number, options?: PyMuPDFType.Page.ReplaceImageOptions): void;
    [Method$c.run](dw: DeviceWrapper, m: PyMuPDFType.MatrixLike | Matrix): void;
    [Method$c.search_for](text: string, options?: PyMuPDFType.Document.SearchPageForOptions): Rect[];
    [Method$c.set_artbox](r: PyMuPDFType.RectLike | Rect): void;
    [Method$c.set_bleedbox](r: PyMuPDFType.RectLike | Rect): void;
    [Method$c.set_contents](xref: number): void;
    [Method$c.set_cropbox](r: PyMuPDFType.RectLike | Rect): void;
    [Method$c.set_language](language?: number): void;
    [Method$c.set_mediabox](r: PyMuPDFType.RectLike | Rect): void;
    [Method$c.set_rotation](rotation?: number): void;
    [Method$c.set_trimbox](r: PyMuPDFType.RectLike | Rect): void;
    [Method$c.show_pdf_page](rect: PyMuPDFType.RectLike | Rect, docsrc: Document$1, options?: PyMuPDFType.Page.ShowPdfPageOptions): number;
    [Method$c.update_link](lnk: PyMuPDFType.Link): void;
    [Method$c.widgets](types?: number[]): Widget[];
    [Method$c.wrap_contents](): void;
    [Method$c.write_text](options: PyMuPDFType.Page.WriteTextOptions & {
        writers?: TextWriter;
    }): void;
}

declare const enum Member$d {
    dest = "dest",
    fileSpec = "fileSpec",
    flags = "flags",
    isMap = "isMap",
    isUri = "isUri",
    kind = "kind",
    lt = "lt",
    named = "named",
    newWindow = "newWindow",
    page = "page",
    rb = "rb",
    uri = "uri"
}
declare class linkDest extends PyMuPDFClassBase {
    constructor(obj: Link | Outline, rlink: string);
    constructor(obj: Link | Outline, rlink: string, document: Document$1);
    constructor(ref: PyProxy);
    protected buildOrigin(obj: Link | Outline, rlink: string | null): PyProxy;
    protected buildOrigin(obj: Link | Outline, rlink: string | null, document: Document$1): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$d.dest](): string;
    get [Member$d.fileSpec](): string;
    get [Member$d.flags](): number;
    get [Member$d.isMap](): boolean;
    get [Member$d.isUri](): boolean;
    get [Member$d.kind](): number;
    get [Member$d.lt](): Point;
    get [Member$d.named](): string;
    get [Member$d.newWindow](): boolean;
    get [Member$d.page](): number;
    get [Member$d.rb](): Point;
    get [Member$d.uri](): string;
}

declare const enum Member$c {
    down = "down",
    next = "next",
    page = "page",
    title = "title",
    uri = "uri",
    is_external = "is_external",
    is_open = "is_open",
    dest = "dest"
}
declare const enum Method$b {
    destination = "destination"
}
declare class Outline extends PyMuPDFClassBase {
    constructor(ol: Outline);
    constructor(ref: PyProxy);
    protected buildOrigin(ol: Outline): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$c.down](): Outline;
    get [Member$c.next](): Outline;
    get [Member$c.page](): number;
    get [Member$c.title](): string;
    get [Member$c.uri](): string;
    get [Member$c.is_external](): boolean;
    get [Member$c.is_open](): boolean;
    get [Member$c.dest](): linkDest;
    [Method$b.destination](document: Document): linkDest;
}

declare const enum Member$b {
    chapter_count = "chapter_count",
    FormFonts = "FormFonts",
    is_closed = "is_closed",
    is_dirty = "is_dirty",
    is_encrypted = "is_encrypted",
    is_fast_webaccess = "is_fast_webaccess",
    is_form_pdf = "is_form_pdf",
    is_pdf = "is_pdf",
    is_reflowable = "is_reflowable",
    is_repaired = "is_repaired",
    last_location = "last_location",
    metadata = "metadata",
    markinfo = "markinfo",
    name = "name",
    needs_pass = "needs_pass",
    outline = "outline",
    page_count = "page_count",
    permissions = "permissions",
    pagemode = "pagemode",
    pagelayout = "pagelayout",
    version_count = "version_count"
}
declare const enum Method$a {
    add_layer = "add_layer",
    add_ocg = "add_ocg",
    authenticate = "authenticate",
    bake = "bake",
    can_save_incrementally = "can_save_incrementally",
    chapter_page_count = "chapter_page_count",
    close = "close",
    convert_to_pdf = "convert_to_pdf",
    copy_page = "copy_page",
    del_toc_item = "del_toc_item",
    del_xml_metadata = "del_xml_metadata",
    delete_page = "delete_page",
    delete_pages = "delete_pages",
    embfile_add = "embfile_add",
    embfile_count = "embfile_count",
    embfile_del = "embfile_del",
    embfile_get = "embfile_get",
    embfile_info = "embfile_info",
    embfile_names = "embfile_names",
    embfile_upd = "embfile_upd",
    extract_font = "extract_font",
    extract_image = "extract_image",
    ez_save = "ez_save",
    find_bookmark = "find_bookmark",
    fullcopy_page = "fullcopy_page",
    get_char_widths = "get_char_widths",
    get_layer = "get_layer",
    get_layers = "get_layers",
    get_new_xref = "get_new_xref",
    get_oc = "get_oc",
    get_ocgs = "get_ocgs",
    get_ocmd = "get_ocmd",
    get_outline_xrefs = "get_outline_xrefs",
    get_page_fonts = "get_page_fonts",
    get_page_images = "get_page_images",
    get_page_labels = "get_page_labels",
    get_page_numbers = "get_page_numbers",
    get_page_pixmap = "get_page_pixmap",
    get_page_text = "get_page_text",
    get_page_xobjects = "get_page_xobjects",
    get_sigflags = "get_sigflags",
    get_toc = "get_toc",
    get_xml_metadata = "get_xml_metadata",
    has_annots = "has_annots",
    has_links = "has_links",
    init_doc = "init_doc",
    insert_page = "insert_page",
    insert_pdf = "insert_pdf",
    insert_file = "insert_file",
    journal_can_do = "journal_can_do",
    journal_enable = "journal_enable",
    journal_load = "journal_load",
    journal_op_name = "journal_op_name",
    journal_position = "journal_position",
    journal_redo = "journal_redo",
    journal_save = "journal_save",
    journal_start_op = "journal_start_op",
    journal_stop_op = "journal_stop_op",
    journal_undo = "journal_undo",
    layer_ui_configs = "layer_ui_configs",
    layout = "layout",
    load_page = "load_page",
    location_from_page_number = "location_from_page_number",
    make_bookmark = "make_bookmark",
    move_page = "move_page",
    need_appearances = "need_appearances",
    new_page = "new_page",
    next_location = "next_location",
    page_annot_xrefs = "page_annot_xrefs",
    page_cropbox = "page_cropbox",
    page_number_from_location = "page_number_from_location",
    page_xref = "page_xref",
    pages = "pages",
    pdf_catalog = "pdf_catalog",
    pdf_trailer = "pdf_trailer",
    prev_location = "prev_location",
    recolor = "recolor",
    reload_page = "reload_page",
    resolve_link = "resolve_link",
    resolve_names = "resolve_names",
    save = "save",
    saveIncr = "saveIncr",
    save_snapshot = "save_snapshot",
    scrub = "scrub",
    search_page_for = "search_page_for",
    select = "select",
    set_language = "set_language",
    set_layer_ui_config = "set_layer_ui_config",
    set_layer = "set_layer",
    set_markinfo = "set_markinfo",
    set_metadata = "set_metadata",
    set_oc = "set_oc",
    set_ocmd = "set_ocmd",
    set_page_labels = "set_page_labels",
    set_pagemode = "set_pagemode",
    set_pagelayout = "set_pagelayout",
    set_toc_item = "set_toc_item",
    set_toc = "set_toc",
    set_xml_metadata = "set_xml_metadata",
    subset_fonts = "subset_fonts",
    switch_layer = "switch_layer",
    tobytes = "tobytes",
    update_object = "update_object",
    update_stream = "update_stream",
    write = "write",
    xref_copy = "xref_copy",
    xref_get_key = "xref_get_key",
    xref_get_keys = "xref_get_keys",
    xref_is_font = "xref_is_font",
    xref_is_image = "xref_is_image",
    xref_is_stream = "xref_is_stream",
    xref_is_xobject = "xref_is_xobject",
    xref_length = "xref_length",
    xref_object = "xref_object",
    xref_set_key = "xref_set_key",
    xref_stream = "xref_stream",
    xref_stream_raw = "xref_stream_raw",
    xref_xml_metadata = "xref_xml_metadata"
}
declare class Document$1 extends PyMuPDFClassBase {
    constructor();
    constructor(filename: string | null);
    constructor(filename: string | null, stream: ArrayBuffer | null);
    constructor(filename: string | null, stream: ArrayBuffer | null, options: PyMuPDFType.Document.DocumentOptions);
    constructor(ref: PyProxy);
    protected buildOrigin(): PyProxy;
    protected buildOrigin(filename: string | null): PyProxy;
    protected buildOrigin(filename: string | null, stream: ArrayBuffer | null): PyProxy;
    protected buildOrigin(filename: string | null, stream: ArrayBuffer | null, options: PyMuPDFType.Document.DocumentOptions): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$b.chapter_count](): number;
    get [Member$b.FormFonts](): string[];
    get [Member$b.is_closed](): boolean;
    get [Member$b.is_dirty](): boolean;
    get [Member$b.is_encrypted](): boolean;
    get [Member$b.is_fast_webaccess](): boolean;
    get [Member$b.is_form_pdf](): boolean;
    get [Member$b.is_pdf](): boolean;
    get [Member$b.is_reflowable](): boolean;
    get [Member$b.is_repaired](): boolean;
    get [Member$b.last_location](): PyMuPDFType.Document.Location | number;
    get [Member$b.metadata](): PyMuPDFType.Document.Metadata;
    get [Member$b.markinfo](): PyMuPDFType.Document.MarkInfo;
    get [Member$b.name](): string;
    get [Member$b.needs_pass](): boolean;
    get [Member$b.outline](): Outline;
    get [Member$b.page_count](): number;
    get [Member$b.permissions](): number;
    get [Member$b.pagemode](): string;
    get [Member$b.pagelayout](): string;
    get [Member$b.version_count](): number;
    [Method$a.add_layer](name: string, creator?: string, on?: number[]): void;
    [Method$a.add_ocg](name: string, options?: PyMuPDFType.Document.AddOcgOptions): number;
    [Method$a.authenticate](password: string): number;
    [Method$a.bake](annots?: boolean, widgets?: boolean): void;
    [Method$a.can_save_incrementally](): boolean;
    [Method$a.chapter_page_count](chapter: number): number;
    [Method$a.close](): void;
    [Method$a.convert_to_pdf](from_page?: number, to_page?: number, rotate?: number): Uint8Array;
    [Method$a.copy_page](pno: number, to?: number): void;
    [Method$a.del_toc_item](idx: number): void;
    [Method$a.del_xml_metadata](): void;
    [Method$a.delete_page](pno?: number): void;
    [Method$a.delete_pages](options: {
        from_page: number;
        to_page: number;
    }): void;
    [Method$a.delete_pages](from: number, to: number): void;
    [Method$a.delete_pages](pno: number): void;
    [Method$a.delete_pages](pages: number[]): void;
    [Method$a.embfile_add](name: string, buffer_: ArrayBuffer, filename?: string, ufilename?: string, desc?: string): number;
    [Method$a.embfile_count](): number;
    [Method$a.embfile_del](item: string | number): void;
    [Method$a.embfile_get](item: string | number): Uint8Array;
    [Method$a.embfile_info](item: string | number): PyMuPDFType.Document.EmbedFileInfo;
    [Method$a.embfile_names](): string[];
    [Method$a.embfile_upd](item: string | number, buffer_?: ArrayBuffer, filename?: string, ufilename?: string, desc?: string): number;
    [Method$a.extract_font](xref?: number, info_only?: boolean, named?: false): PyMuPDFType.Document.ExtractFontList;
    [Method$a.extract_font](xref?: number, info_only?: boolean, named?: true): PyMuPDFType.Document.ExtractFontDict;
    [Method$a.extract_image](xref: number): PyMuPDFType.Document.ExtractImageDict;
    [Method$a.ez_save](filename: string, options?: PyMuPDFType.Document.WriteOptions): void;
    [Method$a.find_bookmark](bookmark: number): PyMuPDFType.Document.Bookmark;
    [Method$a.fullcopy_page](pno: number, to?: number): void;
    [Method$a.get_char_widths](options?: PyMuPDFType.Document.GetCharWidthsOptions): PyMuPDFType.Document.Glyph[];
    [Method$a.get_layer](config?: number): PyMuPDFType.Document.Layer;
    [Method$a.get_layers](): PyMuPDFType.Document.Layer[];
    [Method$a.get_new_xref](): number;
    [Method$a.get_oc](xref: number): number;
    [Method$a.get_ocgs](): Record<number, PyMuPDFType.Document.OptionalContentGroup>;
    [Method$a.get_ocmd](xref: number): PyMuPDFType.Document.GetOCMD;
    [Method$a.get_outline_xrefs](): number[];
    [Method$a.get_page_fonts](pno: number): PyMuPDFType.Document.PageFontSimpleResult[];
    [Method$a.get_page_fonts](pno: number, full: false): PyMuPDFType.Document.PageFontSimpleResult[];
    [Method$a.get_page_fonts](pno: number, full: true): PyMuPDFType.Document.PageFontFullResult[];
    [Method$a.get_page_images](pno: number): PyMuPDFType.Document.PageImageSimpleResult[];
    [Method$a.get_page_images](pno: number, full: false): PyMuPDFType.Document.PageImageSimpleResult[];
    [Method$a.get_page_images](pno: number, full: true): PyMuPDFType.Document.PageImageFullResult[];
    [Method$a.get_page_labels](): PyMuPDFType.Document.Label[];
    [Method$a.get_page_numbers](label: string, only_one?: boolean): number[];
    [Method$a.get_page_pixmap](pno: number, options?: PyMuPDFType.Document.GetPagePixmapOptions): Pixmap;
    [Method$a.get_page_text](pno: number, options?: PyMuPDFType.Document.GetPageTextOptions): string;
    [Method$a.get_page_xobjects](pno: number): PyMuPDFType.Document.GetPageXObjectResult;
    [Method$a.get_sigflags](): PyMuPDFType.Document.GetSigFlagsResult;
    [Method$a.get_toc](): PyMuPDFType.Document.TocSimple[];
    [Method$a.get_toc](simple: true): PyMuPDFType.Document.TocSimple[];
    [Method$a.get_toc](simple: false): PyMuPDFType.Document.TocFull[];
    [Method$a.get_xml_metadata](): string;
    [Method$a.has_annots](): boolean;
    [Method$a.has_links](): boolean;
    [Method$a.init_doc](): void;
    [Method$a.insert_page](options: PyMuPDFType.Document.InsertPageOptions): number;
    [Method$a.insert_pdf](doc: Document$1, options?: PyMuPDFType.Document.InsertPdfOptions): void;
    [Method$a.insert_file](infile: Document$1 | Pixmap | string, options?: PyMuPDFType.Document.InsertFileOptions): void;
    [Method$a.journal_can_do](): PyMuPDFType.Document.JournalCanDoResult;
    [Method$a.journal_enable](): void;
    [Method$a.journal_load](filename: string | Uint8Array): void;
    [Method$a.journal_op_name](step: number): string;
    [Method$a.journal_position](): PyMuPDFType.Document.JournalPositionResult;
    [Method$a.journal_redo](): true;
    [Method$a.journal_save](filename: string): void;
    [Method$a.journal_start_op](name: string): void;
    [Method$a.journal_stop_op](): void;
    [Method$a.journal_undo](): true;
    [Method$a.layer_ui_configs](): PyMuPDFType.Document.LayoutUIConfig[];
    [Method$a.layout](options?: PyMuPDFType.Document.LayoutOptions): void;
    [Method$a.load_page](id: number | PyMuPDFType.Document.Location): Page;
    [Method$a.location_from_page_number](pno: number): PyMuPDFType.Document.Location;
    [Method$a.make_bookmark](loc: PyMuPDFType.Document.Bookmark): number;
    [Method$a.move_page](pno: number, to?: number): void;
    [Method$a.need_appearances](value?: boolean): boolean | null;
    [Method$a.new_page](pno?: number, width?: number, height?: number): Page;
    [Method$a.next_location](page_id: PyMuPDFType.Document.Location | number): PyMuPDFType.Document.Location;
    [Method$a.page_cropbox](pno: number): Rect;
    [Method$a.page_number_from_location](page_id: number | PyMuPDFType.Document.Location): number;
    [Method$a.page_xref](pno: number): number;
    [Method$a.pages](start?: number, stop?: number, step?: number): Page[];
    [Method$a.pdf_catalog](): number;
    [Method$a.pdf_trailer](compressed?: boolean): number;
    [Method$a.prev_location](page_id: PyMuPDFType.Document.Location | number): PyMuPDFType.Document.Location;
    [Method$a.recolor](components?: number): void;
    [Method$a.reload_page](page: Page): Page;
    [Method$a.resolve_link](): number;
    [Method$a.resolve_link](uri: string): number;
    [Method$a.resolve_link](uri: string, chapters: true): PyMuPDFType.Document.Location;
    [Method$a.resolve_link](uri: string, chapters: false): number;
    [Method$a.resolve_names](): Record<string, PyMuPDFType.Document.ResolveNameResult>;
    [Method$a.save](outfile: string, options?: PyMuPDFType.Document.SaveOptions): void;
    [Method$a.saveIncr](): void;
    [Method$a.save_snapshot](filename: string): void;
    [Method$a.scrub](options?: PyMuPDFType.Document.ScrubOptions): void;
    [Method$a.search_page_for](pno: number, text: string, options?: PyMuPDFType.Document.SearchPageForOptions): Rect[];
    [Method$a.select](s: number[]): void;
    [Method$a.set_language](language?: number): true;
    [Method$a.set_layer_ui_config](number: number | string, action?: number): void;
    [Method$a.set_layer](config: number, options?: PyMuPDFType.Document.LayerOptions): void;
    [Method$a.set_markinfo](markinfo: PyMuPDFType.Document.MarkInfo): boolean;
    [Method$a.set_metadata](m: Partial<PyMuPDFType.Document.Metadata>): void;
    [Method$a.set_oc](xref: number, ocxref: number): void;
    [Method$a.set_ocmd](options?: PyMuPDFType.Document.SetOcmdOptions): number;
    [Method$a.set_page_labels](labels: PyMuPDFType.Document.Label[]): void;
    [Method$a.set_pagemode](pagemode: PyMuPDFType.Document.PageMode): void;
    [Method$a.set_pagelayout](pagelayout: PyMuPDFType.Document.PageLayout): void;
    [Method$a.set_toc_item](idx: number, options?: PyMuPDFType.Document.SetTocItemOptions): void;
    [Method$a.set_toc](toc: (PyMuPDFType.Document.TocFull | PyMuPDFType.Document.TocSimple)[], collase?: number): number;
    [Method$a.set_xml_metadata](xml: string): void;
    [Method$a.subset_fonts](verbose?: boolean, fallback?: boolean): number;
    [Method$a.switch_layer](config: number, as_default?: boolean): void;
    [Method$a.tobytes](options?: PyMuPDFType.Document.WriteOptions): Uint8Array;
    [Method$a.update_object](xref: number, text: string, page?: Page): number;
    [Method$a.update_stream](xref: number, stream: ArrayBuffer, isNew?: boolean, compress?: boolean): void;
    [Method$a.write](options?: PyMuPDFType.Document.WriteOptions): Uint8Array;
    [Method$a.xref_copy](source: number, target: number, keep?: string[]): void;
    [Method$a.xref_get_key](xref: number, key: string): PyMuPDFType.Document.XrefGetKey;
    [Method$a.xref_get_keys](xref: number): string[];
    [Method$a.xref_is_font](xref: number): boolean;
    [Method$a.xref_is_image](xref: number): boolean;
    [Method$a.xref_is_stream](xref?: number): boolean;
    [Method$a.xref_is_xobject](xref: number): boolean;
    [Method$a.xref_length](): number;
    [Method$a.xref_object](xref: number, compressed?: boolean, ascii?: number): string;
    [Method$a.xref_set_key](xref: number, key: string, value: string): void;
    [Method$a.xref_stream](xref: number): Uint8Array;
    [Method$a.xref_stream_raw](xref: number): Uint8Array;
    [Method$a.xref_xml_metadata](): number;
}

declare const enum Member$a {
    width = "width",
    height = "height",
    size = "size",
    mode = "mode"
}
declare const enum Method$9 {
    close = "close",
    tobytes = "tobytes",
    tobitmap = "tobitmap",
    convert = "convert",
    save = "save",
    transpose = "transpose",
    effect_spread = "effect_spread"
}
declare class PillowImage extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(...args: unknown[]): PyProxy;
    get [Member$a.width](): number;
    get [Member$a.height](): number;
    get [Member$a.size](): [number, number];
    get [Member$a.mode](): string;
    [Method$9.close](): void;
    [Method$9.tobytes](encoder_name?: string, ...args: unknown[]): Uint8Array;
    [Method$9.tobitmap](name?: string): Uint8Array;
    [Method$9.convert](options?: PyMuPDFType.PillowImage.ConvertOptions): PillowImage;
    [Method$9.save](filename: string, options?: PyMuPDFType.PillowImage.ImageSaveOptions): void;
    [Method$9.transpose](method: number): PillowImage;
    [Method$9.effect_spread](distance: number): PillowImage;
}

declare const enum Member$9 {
    alpha = "alpha",
    colorspace = "colorspace",
    digest = "digest",
    height = "height",
    interpolate = "interpolate",
    is_monochrome = "is_monochrome",
    is_unicolor = "is_unicolor",
    irect = "irect",
    n = "n",
    samples = "samples",
    samples_mv = "samples_mv",
    samples_ptr = "samples_ptr",
    size = "size",
    stride = "stride",
    width = "width",
    x = "x",
    xres = "xres",
    y = "y",
    yres = "yres"
}
declare const enum Method$8 {
    clear_with = "clear_with",
    color_count = "color_count",
    color_topusage = "color_topusage",
    copy = "copy",
    gamma_with = "gamma_with",
    invert_irect = "invert_irect",
    pdfocr_save = "pdfocr_save",
    pdfocr_tobytes = "pdfocr_tobytes",
    pil_image = "pil_image",
    pil_save = "pil_save",
    pil_tobytes = "pil_tobytes",
    pixel = "pixel",
    save = "save",
    set_alpha = "set_alpha",
    set_dpi = "set_dpi",
    set_origin = "set_origin",
    set_pixel = "set_pixel",
    set_rect = "set_rect",
    shrink = "shrink",
    tint_with = "tint_with",
    tobytes = "tobytes",
    warp = "warp"
}
declare class Pixmap extends PyMuPDFClassBase {
    constructor(colorspace: Colorspace, irect: PyMuPDFType.IRectLike);
    constructor(colorspace: Colorspace, irect: PyMuPDFType.IRectLike, alpha: boolean);
    constructor(colorspace: Colorspace, source: Pixmap);
    constructor(source: Pixmap, mask: Pixmap);
    constructor(source: Pixmap, width: number, height: number, clip: PyMuPDFType.IRectLike);
    constructor(source: Pixmap);
    constructor(source: Pixmap, alpha: boolean);
    constructor(filename: string);
    constructor(stream: ArrayBuffer);
    constructor(colorspace: Colorspace, width: number, height: number, samples: ArrayBuffer, alpha: boolean);
    constructor(doc: Document$1, xref: number);
    constructor(ref: PyProxy);
    protected buildOrigin(colorspace: Colorspace, irect: PyMuPDFType.IRectLike): PyProxy;
    protected buildOrigin(colorspace: Colorspace, irect: PyMuPDFType.IRectLike, alpha: boolean): PyProxy;
    protected buildOrigin(colorspace: Colorspace, source: Pixmap): PyProxy;
    protected buildOrigin(source: Pixmap, mask: Pixmap): PyProxy;
    protected buildOrigin(source: Pixmap, width: number, height: number, clip: PyMuPDFType.IRectLike): PyProxy;
    protected buildOrigin(source: Pixmap): PyProxy;
    protected buildOrigin(source: Pixmap, alpha: number): PyProxy;
    protected buildOrigin(filename: string): PyProxy;
    protected buildOrigin(stream: ArrayBuffer): PyProxy;
    protected buildOrigin(colorspace: Colorspace, width: number, height: number, samples: ArrayBuffer, alpha: boolean): PyProxy;
    protected buildOrigin(doc: Document$1, xref: number): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$9.alpha](): boolean;
    get [Member$9.colorspace](): Colorspace;
    get [Member$9.digest](): Uint8Array;
    get [Member$9.height](): number;
    get [Member$9.interpolate](): boolean;
    get [Member$9.is_monochrome](): boolean;
    get [Member$9.is_unicolor](): boolean;
    get [Member$9.irect](): IRect;
    get [Member$9.n](): number;
    get [Member$9.samples](): Uint8Array;
    get [Member$9.samples_mv](): Uint8Array;
    get [Member$9.samples_ptr](): number;
    get [Member$9.size](): number;
    get [Member$9.stride](): number;
    get [Member$9.width](): number;
    get [Member$9.x](): number;
    get [Member$9.xres](): number;
    get [Member$9.y](): number;
    get [Member$9.yres](): number;
    [Method$8.clear_with](value?: number, bbox?: PyMuPDFType.IRectLike | IRect): void;
    [Method$8.color_topusage](clip?: PyMuPDFType.RectLike | Rect): [number, Uint8Array];
    [Method$8.copy](src: Pixmap, bbox: PyMuPDFType.IRectLike | IRect): Pixmap;
    [Method$8.gamma_with](gamma: number): void;
    [Method$8.invert_irect](bbox?: PyMuPDFType.IRectLike | IRect): boolean;
    [Method$8.pil_image](): PillowImage;
    [Method$8.pil_save](filename: string, options?: PyMuPDFType.PillowImage.ImageSaveOptions): void;
    [Method$8.pil_tobytes](options: PyMuPDFType.PillowImage.ImageSaveOptions): Uint8Array;
    [Method$8.pixel](x: number, y: number): [number, number, number, number];
    [Method$8.set_alpha](alphavalues?: Uint8Array, premultiply?: boolean, opaque?: PyMuPDFType.ColorSequence): void;
    [Method$8.set_dpi](xres: number, yres: number): void;
    [Method$8.set_origin](x: number, y: number): void;
    [Method$8.set_pixel](x: number, y: number, color: PyMuPDFType.ColorSequence): void;
    [Method$8.set_rect](bbox: PyMuPDFType.IRectLike | IRect, color: PyMuPDFType.ColorSequence): boolean;
    [Method$8.shrink](n: number): void;
    [Method$8.tint_with](black: number, white: number): void;
    [Method$8.tobytes](output?: string, jpg_quality?: number): Uint8Array;
    [Method$8.warp](quad: Quad, width: number, height: number): Pixmap;
}

declare const enum Member$8 {
    rect = "rect"
}
declare const enum Method$7 {
    run = "run",
    get_pixmap = "get_pixmap",
    get_textpage = "get_textpage"
}
declare class DisplayList extends PyMuPDFClassBase {
    constructor(mediabox: PyMuPDFType.RectLike | Rect);
    constructor(displayList: DisplayList);
    constructor(ref: PyProxy);
    protected buildOrigin(mediabox: PyMuPDFType.RectLike | Rect): PyProxy;
    protected buildOrigin(displayList: DisplayList): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$8.rect](): Rect;
    [Method$7.run](device: DeviceWrapper, matrix: Matrix | PyMuPDFType.MatrixLike, area: Rect | PyMuPDFType.RectLike): void;
    [Method$7.get_pixmap](matrix?: Matrix | PyMuPDFType.MatrixLike, colorspace?: Colorspace, alpha?: number, clip?: IRect | PyMuPDFType.IRectLike): Pixmap;
    [Method$7.get_textpage](flags?: number): TextPage;
}

declare class DeviceWrapper extends PyMuPDFClassBase {
    constructor(deviceWrapper: DeviceWrapper);
    constructor(disaplyList: DisplayList);
    constructor(textpage: TextPage);
    constructor(textpage: TextPage, flags: number);
    constructor(pixmap: Pixmap, clip: IRect | PyMuPDFType.IRectLike);
    constructor(ref: PyProxy);
    protected buildOrigin(deviceWrapper: DeviceWrapper): PyProxy;
    protected buildOrigin(disaplyList: DisplayList): PyProxy;
    protected buildOrigin(textpage: TextPage): PyProxy;
    protected buildOrigin(textpage: TextPage, flags: number): PyProxy;
    protected buildOrigin(pixmap: Pixmap, clip: IRect | PyMuPDFType.IRectLike): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
}

declare const enum Member$7 {
    depth = "depth",
    heading = "heading",
    id = "id",
    rect = "rect",
    text = "text",
    open_close = "open_close",
    rect_num = "rect_num",
    href = "href",
    page_num = "page_num"
}
declare class Position2 extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$7.depth](): number;
    get [Member$7.heading](): number;
    get [Member$7.id](): string;
    get [Member$7.rect](): PyMuPDFType.RectLike;
    get [Member$7.text](): string | undefined;
    get [Member$7.open_close](): number;
    get [Member$7.rect_num](): number;
    get [Member$7.href](): string | undefined;
    get [Member$7.page_num](): number | undefined;
    getExtraMember<T>(member: string): T;
}

declare namespace PyMuPDFType {
    type RectLike = [number, number, number, number];
    type IRectLike = [number, number, number, number];
    type ColorSequence = [number] | [number, number, number] | [number, number, number, number];
    type ColorString = string;
    type Color = ColorSequence | ColorString;
    type MatrixLike = [number, number, number, number, number, number];
    type PointLike = [number, number];
    type QuadLike = [PointLike, PointLike, PointLike, PointLike];
    type Word = [number, number, number, number, string, number, number, number];
    type Block = [number, number, number, number, string, number, number];
    type PDFColor = Record<string, ColorSequence>;
    type Version = [major: number, minor: number, patch: number];
    type AllVersion = [pymupdf_version: string, mupdf_version: string, timestamp: string];
    interface PageDict<T extends SpanDict = SpanDict> {
        width: number;
        height: number;
        blocks: (BlockDict | TextDict<T>)[];
    }
    interface BlockDict {
        type: 1;
        bbox: RectLike;
        number: number;
        ext: string;
        width: number;
        height: number;
        colorspace: number;
        xres: number;
        yres: number;
        bpc: number;
        transform: MatrixLike;
        size: number;
        image: Uint8Array;
        mask?: Uint8Array;
    }
    interface TextDict<T extends SpanDict = SpanDict> {
        type: 0;
        bbox: RectLike;
        number: number;
        lines: LineDict<T>[];
    }
    interface LineDict<T extends SpanDict = SpanDict> {
        bbox: RectLike;
        wmode: number;
        dir: PointLike;
        spans: T[];
    }
    interface SpanDict {
        bbox: RectLike;
        origin: PointLike;
        font: string;
        ascender: number;
        desender: number;
        size: number;
        flags: number;
        char_flags: number;
        color: number;
        alpha: number;
        text: string;
    }
    interface SpanRawDict extends SpanDict {
        chars: CharDict[];
    }
    interface CharDict {
        origin: PointLike;
        bbox: RectLike;
        synthetic: boolean;
        c: string;
    }
    interface Table {
        bbox: RectLike;
        rows: number;
        columns: number;
    }
    interface Image {
        number: number;
        bbox: Rect;
        width: number;
        height: number;
        'cs-name': string;
        colorspace: number;
        xres: number;
        yres: number;
        bpc: number;
        size: number;
        'has-mask': boolean;
        transform: MatrixLike;
        image?: Uint8Array;
        ext?: string;
        xref?: number;
        digest?: Uint8Array;
    }
    interface Link {
        kind: number;
        from: RectLike | Rect;
        page?: number;
        to?: PointLike | Point;
        file?: string;
        uri?: string;
        xref?: number;
        nameddest?: string;
        id?: string;
    }
    interface Path {
        type: 'f' | 's' | 'fs';
        items: PathCommand[];
        color?: ColorSequence;
        fill?: ColorSequence;
        width?: number;
        lineCap?: [number, number, number];
        lineJoin?: number;
        dashes?: number[];
        even_odd?: boolean;
        closePath?: boolean;
        fill_opacity?: number;
        stroke_opacity?: number;
        rect?: Rect;
        layer?: string;
        seqno?: number;
        level?: number;
    }
    type ExtendPath = Path | ClipPath | GroupPath;
    interface ClipPath {
        type: 'clip';
        items: Path[];
        closePath?: boolean;
        scissor?: RectLike;
        level?: number;
        layer?: string;
        rect?: RectLike;
    }
    interface GroupPath {
        type: 'group';
        rect?: RectLike;
        layer?: string;
        level?: number;
        knockout?: boolean;
        isolated?: boolean;
        blendmode?: string;
        opacity?: number;
    }
    type PathCommand = LineCommand | CurveCommand | RectCommand | QuadCommand;
    type LineCommand = ['l', Point, Point];
    type CurveCommand = ['c', Point, Point, Point, Point];
    type RectCommand = ['re', Rect, number];
    type QuadCommand = ['qu', Quad];
    namespace Document {
        interface DocumentOptions {
            filetype?: string;
            rect?: RectLike;
            width?: number;
            height?: number;
            fontsize?: number;
        }
        interface Label {
            startpage: number;
            prefix: string;
            style: string;
            firstpagenum: number;
        }
        interface InsertPageOptions {
            pno: number;
            text?: string;
            fontsize?: number;
            width?: number;
            height?: number;
            fontname?: number;
            fontfile?: string | null;
            color?: Color;
        }
        interface ScrubOptions {
            attached_files?: boolean;
            clean_pages?: boolean;
            embedded_files?: boolean;
            hidden_text?: boolean;
            javascript?: boolean;
            metadata?: boolean;
            redactions?: boolean;
            redact_images?: number;
            remove_links?: boolean;
            reset_fields?: boolean;
            reset_responses?: boolean;
            thumbnails?: boolean;
            xml_metadata?: boolean;
        }
        interface InsertPdfOptions {
            from_page?: number;
            to_page?: number;
            start_at?: number;
            rotate?: number;
            links?: boolean;
            annots?: boolean;
            widgets?: boolean;
            join_duplicates?: boolean;
            show_progress?: number;
            final?: number;
        }
        interface SaveOptions {
            garbage?: number;
            clean?: boolean;
            deflate?: boolean;
            deflate_images?: boolean;
            deflate_fonts?: boolean;
            incremental?: boolean;
            ascii?: boolean;
            expand?: boolean;
            linear?: boolean;
            pretty?: boolean;
            no_new_id?: boolean;
            encryption?: number;
            permissions?: number;
            owner_pw?: string;
            user_pw?: string;
            use_objstms?: boolean;
        }
        interface Metadata {
            format: string;
            title: string;
            author: string;
            subject: string;
            keywords: string;
            creator: string;
            producer: string;
            creationDate: string;
            modDate: string;
            trapped: string;
            encryption?: string;
        }
        interface MarkInfo {
            Marked: boolean;
            UserProperties: boolean;
            Suspects: boolean;
        }
        interface EmbedFileInfo {
            name: string;
            filename: string;
            ufilename: string;
            description: string;
            size: number;
            length: number;
            creationDate: string;
            modDate: string;
            checksum?: string;
        }
        type ExtractFontList = [string, string, string, Uint8Array];
        interface ExtractFontDict {
            name: string;
            ext: string;
            type: string;
            content: Uint8Array;
        }
        interface ExtractImageDict {
            ext: string;
            smask: number;
            width: number;
            height: number;
            colorspace: number;
            'cs-name': number;
            xres: number;
            yres: number;
            image: Uint8Array;
        }
        interface WriteOptions extends SaveOptions {
            preserve_metadata?: number;
            compression_effort?: number;
        }
        type Bookmark = [chapter: number, pno: number];
        interface Layer {
            number: number;
            name: string;
            creator: string;
        }
        interface OptionalContentGroup {
            name: string;
            on: boolean;
            intent: string[];
            usage?: string;
        }
        type PageFontSimpleResult = [xref: number, ext: string, type: string, basefont: string, name: string, encofing: string];
        type PageFontFullResult = [...PageFontSimpleResult, referencer: number];
        type PageImageSimpleResult = [
            xref: number,
            smask: number,
            width: number,
            height: number,
            bpc: number,
            colorspace: string,
            alt_colorspace: string,
            name: string,
            filter: string
        ];
        type PageImageFullResult = [...PageImageSimpleResult, referencer: number];
        interface GetPagePixmapOptions {
            matrix?: MatrixLike | Matrix;
            dpi?: number;
            colorspace?: Colorspace;
            clip?: RectLike | Rect;
            alpha?: boolean;
            annots?: boolean;
        }
        interface GetPageTextOptions {
            option?: string;
            clip?: RectLike | Rect;
            flags?: number;
            textpage?: TextPage;
            sort?: boolean;
        }
        type GetPageXObjectResult = [xref: number, name: string, invoker: number, bbox: Rect];
        type GetSigFlagsResult = -1 | 1 | 3;
        type TocSimple = [lvl: number, title: string, page: number];
        type TocFull = [...TocSimple, dest: TocDestDict];
        interface TocDestDict {
            kind: number;
            zoom: number;
            xref: number;
            color?: ColorSequence;
            bold?: boolean;
            italic?: boolean;
            collapse?: boolean;
            nameddest?: string;
            file?: string;
            page?: number;
            to?: PointLike | Point;
        }
        interface InsertFileOptions {
            from_page?: number;
            to_page?: number;
            start_at?: number;
            rotate?: number;
            links?: boolean;
            annots?: boolean;
            show_progress?: number;
            final?: number;
        }
        interface JournalCanDoResult {
            undo: boolean;
            redo: boolean;
        }
        type JournalPositionResult = [step: number, steps: number];
        interface LayoutUIConfig {
            depth: number;
            locked: boolean;
            number: number;
            on: boolean;
            text: string;
            type: string;
        }
        interface LayoutOptions {
            rect?: RectLike | Rect;
            width?: number;
            height?: number;
            fontsize?: number;
        }
        type Location = [chapter: number, pno: number];
        type ResolveNameResult = {
            page: number;
            to: PointLike;
            zoom: number;
        } | {
            page: number;
            dest: string;
        };
        interface SearchPageForOptions {
            quads?: boolean;
            clip?: RectLike | Rect;
            flags?: number;
            textpage?: TextPage;
        }
        type Basestate = 'ON' | 'OFF' | 'Unchanged';
        interface Layer {
            on?: number[];
            off?: number[];
            basestate: Basestate;
            rbgroups?: number[][];
        }
        interface LayerOptions {
            on?: number[];
            off?: number[];
            basestate?: Basestate;
            rbgroups?: number[][];
            locked?: number[];
        }
        type Policy = 'AnyOn' | 'AnyOff' | 'AllOn' | 'AllOff';
        type VisibilityExpression = (number | 'and' | 'or' | 'not' | VisibilityExpression)[];
        type PageMode = 'UseNone' | 'UseOutlines' | 'UseThumbs' | 'FullScreen' | 'UseOC' | 'UseAttachments';
        type PageLayout = 'SinglePage' | 'OneColumn' | 'TwoColumnLeft' | 'TwoColumnRight' | 'TwoPageLeft' | 'TwoPageRight';
        interface GetOCMD {
            xref: number;
            ocgs: number[];
            policy: Policy;
            ve: VisibilityExpression;
        }
        interface SetTocItemOptions {
            dest_dict?: TocDestDict;
            kind?: number;
            pno?: number;
            uri?: string;
            title?: string;
            to?: PointLike | Point;
            filename?: string;
            zoom?: number;
        }
        type XrefGetKey = [type: string, text: string];
        type Glyph = [glyph_code: number, width: number];
        interface FontDict {
            name: string;
            ext: string;
            stype: string;
            ordering: number;
            simple: boolean;
        }
        interface GetCharWidthsOptions {
            xref?: number;
            limit?: number;
            idx?: number;
            fontdict?: FontDict;
        }
        type ResolveLinkResult = [page_id: number, x: number, y: number];
        interface SetOcmdOptions {
            xref?: number;
            ocgs?: number[];
            polycy?: Document.Policy;
            ve?: VisibilityExpression;
        }
        interface AddOcgOptions {
            config?: number;
            on?: boolean;
            intent?: string;
            usage?: string;
        }
    }
    namespace Page {
        export interface InsertTextOptions {
            fontname?: string;
            fontfile?: string;
            encoding?: number;
            fontsize?: number;
            color?: ColorSequence;
            fill?: ColorSequence;
            rotate?: number;
            render_mode?: number;
            miter_limit?: number | null;
            border_width?: number;
            morph?: [Point | PointLike, Matrix | MatrixLike];
            overlay?: boolean;
            stroke_opacity?: number;
            fill_opacity?: number;
            oc?: number;
        }
        export interface InsertTextboxOptions extends InsertTextOptions {
            set_simple?: boolean;
            lineheight?: number;
            expandtabs?: number;
            align?: number;
        }
        export interface InsertImageOptions {
            alpha?: number;
            filename?: string;
            height?: number;
            keep_proportion?: boolean;
            mask?: ArrayBuffer;
            oc?: number;
            overlay?: boolean;
            pixmap?: Pixmap;
            rotate?: number;
            stream?: ArrayBuffer;
            width?: number;
            xref?: number;
        }
        export interface FindTablesOptions {
            clip?: RectLike;
            strategy?: string;
            vertical_strategy?: string;
            horizontal_strategy?: string;
            vertical_lines?: number[];
            horizontal_lines?: number[];
            snap_tolerance?: number;
            snap_x_tolerance?: number;
            snap_y_tolerance?: number;
            join_tolerance?: number;
            join_x_tolerance?: number;
            join_y_tolerance?: number;
            edge_min_length?: number;
            min_words_vertical?: number;
            min_words_horizontal?: number;
            intersection_tolerance?: number;
            intersection_x_tolerance?: number;
            intersection_y_tolerance?: number;
            text_tolerance?: number;
            text_x_tolerance?: number;
            text_y_tolerance?: number;
            add_lines?: [PointLike, PointLike][];
            add_boxes?: RectLike[];
            paths?: Path[];
        }
        export interface GetTextOptions {
            option?: string;
            clip?: RectLike | Rect;
            flags?: number;
            textpage?: TextPage;
            sort?: boolean;
            delimiters?: string;
            tolerance?: number;
        }
        export interface AddFreetextAnnotOptions {
            fontsize?: number;
            fontname?: string;
            text_color?: number | ColorSequence;
            fill_color?: number | ColorSequence;
            border_color?: number | ColorSequence;
            border_width?: number;
            dashes?: number[];
            callout?: [PointLike, PointLike] | [PointLike, PointLike, PointLike];
            line_end?: number;
            opacity?: number;
            align?: number;
            rotate?: number;
            richtext?: boolean;
            style?: string;
        }
        export interface AddFileAnnotOptions {
            ufilename?: string;
            desc?: string;
            icon?: string;
        }
        export interface AddMarkdownAnnotOptions {
            quads?: (RectLike | QuadLike | Rect | Quad)[];
            start?: PointLike | Point;
            stop?: PointLike | Point;
            clip?: RectLike | Rect;
        }
        export interface AddRedactAnnotOptions {
            text?: string;
            fontname?: string;
            fontsize?: number;
            align?: number;
            fill?: ColorSequence;
            text_color?: ColorSequence;
            cross_out?: boolean;
        }
        export interface ApplyRedactionsOptions {
            images?: number;
            graphics?: number;
            text?: number;
        }
        export interface ClusterDrawings {
            clip?: RectLike | Rect;
            drawings?: Path[];
            x_tolerance?: number;
            y_tolerance?: number;
            final_filter?: boolean;
        }
        export interface DrawOptions {
            color?: ColorSequence;
            fill?: ColorSequence;
            width?: number;
            morph?: [Point | PointLike, Matrix | MatrixLike];
            closePath?: boolean;
            lineCap?: number;
            lineJoin?: number;
            overlay?: boolean;
            stroke_opacity?: number;
            fill_opacity?: number;
            oc?: number;
        }
        export interface InsertFontOptions {
            fontname?: string;
            fontfile?: string;
            fontbuffer?: ArrayBuffer;
            set_simple?: boolean;
            wmode?: number;
            encoding?: number;
        }
        export interface InsertHtmlboxOptions {
            css?: string;
            scale_low?: number;
            rotate?: number;
            oc?: number;
            opacity?: number;
            overlay?: boolean;
        }
        export interface ReplaceImageOptions {
            filename?: string;
            pixmap?: Pixmap;
            stream?: ArrayBuffer;
        }
        export interface ShowPdfPageOptions {
            pno?: number;
            keep_proportion?: boolean;
            overlay?: boolean;
            oc?: number;
            rotate?: number;
            clip?: RectLike | Rect;
        }
        export interface WriteTextOptions {
            rect?: RectLike | Rect;
            overlay?: boolean;
            color?: ColorSequence;
            opacity?: number;
            keep_proportion?: boolean;
            rotate?: number;
            oc?: number;
        }
        export type AnnotXrefsResult = [xref: number, type: number, subtype: string];
        export type Bboxlog = [type: string, rect: RectLike];
        export type OcType = 'ocg' | 'ocmd';
        export type OcItem = [pname: string, xref: number, octype: OcType];
        type TextTraceChar = [charcode: number, unicode: number, origin: [number, number], bbox: [number, number, number, number]];
        export interface TextTraceSpan {
            dir: [number, number];
            font: string;
            wmode: number;
            flags: number;
            bidi_lvl: number;
            bidi_dir: number;
            ascender: number;
            descender: number;
            colorspace: number;
            color: ColorSequence;
            size: number;
            opacity: number;
            linewidth: number;
            spacewidth: number;
            type: number;
            bbox: RectLike;
            layer: string;
            seqno: number;
            chars: TextTraceChar[];
        }
        export type InsertHtmlBoxResult = [spare_height: number, scale: number];
        export {  };
    }
    namespace Annot {
        interface Border {
            width: number;
            dashes: number[];
            clouds: number;
            style?: string;
        }
        interface Colors {
            fill: ColorSequence | [];
            stroke: ColorSequence | [];
        }
        interface FileInfo {
            filename: string;
            description: string;
            length: number;
            size: number;
        }
        interface Info {
            name: string;
            content: string;
            title: string;
            creationDate: string;
            modDate: string;
            subject: string;
            id: string;
        }
        type Type = [number, string] | [number, string, string];
        interface GetPrixMapOptions {
            matrix?: Matrix;
            dpi?: number;
            colorspace?: Colorspace;
            alpha?: boolean;
        }
        interface GetSoundResult {
            rate: number;
            channels?: number;
            bps?: number;
            encoding?: 'Raw' | 'Signed' | 'muLaw' | 'ALaw';
            compression?: string;
            stream?: Uint8Array;
        }
        interface UpdateOptions {
            opacity?: number;
            blend_mode?: string;
            fontsize?: number;
            text_color?: ColorSequence | number;
            border_color?: ColorSequence | number;
            fill_color?: ColorSequence | number;
            cross_out?: boolean;
            rotate?: number;
        }
    }
    namespace Widget {
        type FieldValue = string | string[] | boolean | null;
        interface ButtonStatesResult {
            normal: [string, string] | null;
            down: [string, string] | null;
        }
    }
    namespace PillowImage {
        export type ImageSaveOptions = PNGSaveOptions | WebpSaveOptions | GenericSaveOptions;
        export interface ConvertOptions {
            mode?: string;
            matrix?: MatrixLike;
            dither?: 'NONE' | 'ORDERED' | 'RASTERIZE' | 'FLOYDSTEINBERG';
            palette?: number;
            color?: number;
        }
        interface BaseSaveOptions {
            dpi?: [number, number];
            optimize?: boolean;
            icc_profile?: Uint8Array | null;
            exif?: Uint8Array | null;
            transparency?: number | Uint8Array;
            save_all?: boolean;
        }
        interface PNGSaveOptions extends BaseSaveOptions {
            format: 'PNG';
            compress_level?: number;
        }
        interface WebpSaveOptions extends BaseSaveOptions {
            format: 'WEBP';
            quality?: number;
            lossless?: boolean;
            method?: number;
        }
        interface GenericSaveOptions extends BaseSaveOptions {
            format: string;
        }
        export {  };
    }
    namespace Archive {
        type Content = string | Uint8Array | ArrayBuffer | [Uint8Array | ArrayBuffer | string, string];
        type Format = 'dir' | 'zip' | 'tar' | 'tree';
        interface Entry {
            entries: string[];
            fmt: Format;
            path?: string;
        }
    }
    namespace Tools {
        interface AntiAliasingLevel {
            graphics: number;
            text: number;
            graphics_min_line_width: number;
        }
        interface FitzConfig {
            'plotter-g': boolean;
            'plotter-rgb': boolean;
            'plotter-cmyk': boolean;
            'plotter-n': boolean;
            pdf: boolean;
            xps: boolean;
            svg: boolean;
            cbz: boolean;
            img: boolean;
            html: boolean;
            epub: boolean;
            jpx: boolean;
            js: boolean;
            icc: boolean;
            'py-memory': boolean;
            base14: boolean;
            tofu: boolean;
            'tofu-cjk': boolean;
            'tofu-cjk-ext': boolean;
            'tofu-cjk-lang': boolean;
            'tofu-emoji': boolean;
            'tofu-historic': boolean;
            'tofu-symbol': boolean;
            'tofu-sil': boolean;
        }
    }
    namespace Story {
        interface WriteStabilizedOptions {
            user_css?: boolean;
            em?: number;
            positionfn?: (pos: Position2) => void;
            pagefn?: (page_num: number, mediabox: Rect, dev: DeviceWrapper | null, after: 0 | 1) => void;
            add_header_ids?: boolean;
        }
    }
    namespace Xml {
        interface Properties {
            align?: string | number;
            bgcolor?: Color;
            bold?: boolean;
            color?: Color;
            columns?: string | number;
            font?: string;
            fontsize?: string | number;
            indent?: string | number;
            italic?: boolean;
            leading?: number;
            letter_spacing?: string | number;
            lineheight?: string | number;
            margins?: string | number;
            pagebreak_after?: boolean;
            pagebreak_before?: boolean;
            word_spacing?: string | number;
            unqid?: string;
            cls?: string;
        }
    }
    namespace TextWriter {
        interface AppendOptions {
            font?: string;
            fontsize?: number;
            language?: string;
            right_to_left?: boolean;
            small_caps?: number;
        }
        interface FillTextboxOptions {
            pos?: PointLike | Point;
            fontsize?: number;
            align?: number;
            right_to_left?: boolean;
            warn?: boolean;
            small_caps?: number;
        }
        interface WriteTextOptions {
            opacity?: number;
            color?: ColorSequence;
            morph?: [Point | PointLike, Matrix | MatrixLike];
            overlay?: boolean;
            oc?: number;
            render_mode?: number;
        }
        type FillTextboxResult = [line: string, space_len: number];
    }
    namespace Font {
        interface ConstructorOptions {
            fontname?: string;
            fontfile?: string;
            fontbuffer?: ArrayBuffer;
            script?: number;
            language?: string;
            ordering?: number;
            is_bold?: number;
            is_italic?: number;
            is_serif?: number;
        }
        interface Flags {
            mono: boolean;
            serif: boolean;
            bold: boolean;
            italic: boolean;
            substitute: boolean;
            stretch: boolean;
            'fake-bold': boolean;
            'fake-italic': boolean;
            opentype: boolean;
            'invalid-bbox': boolean;
            cjk: boolean;
            'cjk-lang': boolean;
            embed: boolean;
            'never-embed': boolean;
        }
        interface BaseOptions {
            fontsize?: number;
            language?: string;
            script?: number;
            wmode?: number;
            small_caps?: number;
        }
    }
    namespace Shape {
        interface FinishOptions {
            width?: number;
            color?: ColorSequence;
            fill?: ColorSequence;
            lineCap?: number;
            lineJoin?: number;
            dashes?: string;
            even_odd?: boolean;
            morph?: [Point | PointLike, Matrix | MatrixLike];
            closePath?: boolean;
            fill_opacity?: number;
            stroke_opacity?: number;
            oc?: number;
        }
        interface InsertTextOptions {
            fontsize?: number;
            lineheight?: number;
            fontname?: string;
            fontfile?: string;
            set_sample?: boolean;
            encoding?: number;
            color?: ColorSequence;
            fill?: ColorSequence;
            render_mode?: number;
            border_width?: number;
            rotate?: number;
            morph?: [Point | PointLike, Matrix | MatrixLike];
            stroke_opacity?: number;
            fill_opacity?: number;
            oc?: number;
        }
    }
}

declare const enum Member$6 {
    bottom_left = "bottom_left",
    bottom_right = "bottom_right",
    height = "height",
    irect = "irect",
    is_empty = "is_empty",
    is_valid = "is_valid",
    is_infinite = "is_infinite",
    top_left = "top_left",
    top_right = "top_right",
    quad = "quad",
    width = "width",
    x0 = "x0",
    x1 = "x1",
    y0 = "y0",
    y1 = "y1"
}
declare const enum Method$6 {
    contains = "contains",
    get_area = "get_area",
    include_point = "include_point",
    include_rect = "include_rect",
    intersect = "intersect",
    intersects = "intersects",
    morph = "morph",
    torect = "torect",
    norm = "norm",
    normalize = "normalize",
    round = "round",
    transform = "transform",
    abs = "abs",
    add = "add",
    subject = "subject",
    multiply = "multiply",
    divide = "divide",
    equals = "equals",
    negative = "negative",
    positive = "positive"
}
declare class Rect extends PyMuPDFClassBase implements Geometry<Rect> {
    constructor();
    constructor(x0: number, y0: number, x1: number, y1: number);
    constructor(top_left: PyMuPDFType.PointLike | Point, bottom_right: PyMuPDFType.PointLike | Point);
    constructor(top_left: PyMuPDFType.PointLike | Point, x1: number, y1: number);
    constructor(x0: number, y: number, bottom_right: PyMuPDFType.PointLike | Point);
    constructor(rect: Rect);
    constructor(sequence: PyMuPDFType.RectLike);
    constructor(ref: PyProxy);
    protected buildOrigin(): PyProxy;
    protected buildOrigin(x0: number, y0: number, x1: number, y1: number): PyProxy;
    protected buildOrigin(top_left: PyMuPDFType.PointLike, bottom_right: PyMuPDFType.PointLike): PyProxy;
    protected buildOrigin(top_left: PyMuPDFType.PointLike, x1: number, y1: number): PyProxy;
    protected buildOrigin(x0: number, y: number, bottom_right: PyMuPDFType.PointLike): PyProxy;
    protected buildOrigin(rect: Rect): PyProxy;
    protected buildOrigin(sequence: PyMuPDFType.RectLike): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$6.bottom_left](): Point;
    get [Member$6.bottom_right](): Point;
    get [Member$6.height](): number;
    get [Member$6.irect](): IRect;
    get [Member$6.is_empty](): boolean;
    get [Member$6.is_valid](): boolean;
    get [Member$6.is_infinite](): boolean;
    get [Member$6.top_left](): Point;
    get [Member$6.top_right](): Point;
    get [Member$6.quad](): Quad;
    get [Member$6.width](): number;
    get [Member$6.x0](): number;
    get [Member$6.x1](): number;
    get [Member$6.y0](): number;
    get [Member$6.y1](): number;
    [Method$6.contains](x: PyMuPDFType.PointLike | Point | PyMuPDFType.RectLike | Rect): boolean;
    [Method$6.get_area](unit?: string): number;
    [Method$6.include_point](p: PyMuPDFType.PointLike | Point): Rect;
    [Method$6.include_rect](r: PyMuPDFType.RectLike | Rect): Rect;
    [Method$6.intersect](r: PyMuPDFType.RectLike | Rect): Rect;
    [Method$6.intersects](r: PyMuPDFType.RectLike | Rect): boolean;
    [Method$6.morph](fixpoint: PyMuPDFType.PointLike | Point, matrix: PyMuPDFType.MatrixLike | Matrix): Quad;
    [Method$6.torect](rect: PyMuPDFType.RectLike | Rect): Matrix;
    [Method$6.norm](): number;
    [Method$6.normalize](): Rect;
    [Method$6.round](): IRect;
    [Method$6.transform](m: PyMuPDFType.MatrixLike | Matrix): Rect;
    [Method$6.abs](): number;
    [Method$6.add](item: PyMuPDFType.RectLike | Rect | number): Rect;
    [Method$6.subject](item: PyMuPDFType.RectLike | Rect | number): Rect;
    [Method$6.multiply](item: PyMuPDFType.MatrixLike | Matrix | number): Rect;
    [Method$6.divide](item: PyMuPDFType.MatrixLike | Matrix | number): Rect;
    [Method$6.equals](item: PyMuPDFType.RectLike | Rect): boolean;
    [Method$6.negative](): Rect;
    [Method$6.positive](): Rect;
}

declare namespace PyMuPDF4LLMType {
    export interface ToMarkdownOptions {
        pages?: number[];
        hdr_info?: ((span: PyMuPDFType.SpanDict, page?: any) => string) | {
            get_header_id: (span: PyMuPDFType.SpanDict, page?: any) => string;
        } | false;
        write_images?: boolean;
        embed_images?: boolean;
        ignore_images?: boolean;
        ignore_graphics?: boolean;
        dpi?: number;
        filename?: string;
        image_path?: string;
        image_format?: string;
        image_size_limit?: number;
        force_text?: boolean;
        margins?: number | [number, number] | [number, number, number, number];
        page_chunks?: boolean;
        page_width?: number;
        page_height?: number;
        table_strategy?: string;
        graphics_limit?: number;
        ignore_code?: boolean;
        extract_words?: boolean;
        show_progress?: boolean;
        use_glyphs?: boolean;
    }
    export interface ToMarkdownResult {
        metadata: Metadata;
        toc_items: [number, string, number][];
        tables: PyMuPDFType.Table[];
        images: PyMuPDFType.Image[];
        graphics: Rect[];
        text: string;
        words: PyMuPDFType.Word[];
    }
    interface Metadata {
        format: string;
        title: string;
        author: string;
        subject: string;
        keywords: string;
        creator: string;
        producer: string;
        creationDate: string;
        modDate: string;
        trapped: string;
        file_path: string;
        page_count: number;
        page_number: number;
        encryption?: string;
    }
    export {  };
}

declare const enum Member$5 {
    header_id = "header_id",
    body_limit = "body_limit"
}
declare const enum Method$5 {
    get_header_id = "get_header_id"
}
declare class IdentifyHeaders extends PyMuPDFClassBase {
    constructor(doc: Document$1 | string);
    constructor(doc: Document$1 | string, pages: number[] | null);
    constructor(doc: Document$1 | string, pages: number[] | null, body_limit: number);
    constructor(doc: Document$1 | string, pages: number[] | null, body_limit: number, max_levels: number);
    constructor(ref: PyProxy);
    protected buildOrigin(doc: Document$1 | string): PyProxy;
    protected buildOrigin(doc: Document$1 | string, pages: number[] | null): PyProxy;
    protected buildOrigin(doc: Document$1 | string, pages: number[] | null, body_limit: number): PyProxy;
    protected buildOrigin(doc: Document$1 | string, pages: number[] | null, body_limit: number, max_levels: number): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    [Method$5.get_header_id](span: PyMuPDFType.SpanDict, page?: Page | null): string;
    get [Member$5.header_id](): Record<string, string>;
    get [Member$5.body_limit](): number;
}

declare const enum Method$4 {
    get_header_id = "get_header_id"
}
declare class TocHeaders extends PyMuPDFClassBase {
    constructor(doc: Document$1 | string);
    constructor(ref: PyProxy);
    protected buildOrigin(doc: Document$1 | string): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    [Method$4.get_header_id](span: PyMuPDFType.SpanDict, page?: Page | null): any;
}

declare const enum Method$3 {
    begin_page = "begin_page",
    end_page = "end_page",
    close = "close"
}
declare class DocumentWriter extends PyMuPDFClassBase {
    constructor(path: string);
    constructor(path: string, options: string);
    constructor(ref: PyProxy);
    protected buildOrigin(path: string): PyProxy;
    protected buildOrigin(path: string, options: string): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    [Method$3.begin_page](mediabox: Rect | PyMuPDFType.RectLike): DeviceWrapper;
    [Method$3.end_page](): void;
    [Method$3.close](): void;
}

declare const enum Member$4 {
    fitz_config = "fitz_config",
    store_maxsize = "store_maxsize",
    store_size = "store_size"
}
declare const enum Method$2 {
    gen_id = "gen_id",
    store_shrink = "store_shrink",
    mupdf_warnings = "mupdf_warnings",
    mupdf_display_errors = "mupdf_display_errors",
    mupdf_display_warnings = "mupdf_display_warnings",
    reset_mupdf_warnings = "reset_mupdf_warnings",
    set_aa_level = "set_aa_level",
    set_annot_stem = "set_annot_stem",
    set_small_glyph_heights = "set_small_glyph_heights",
    set_subset_fontnames = "set_subset_fontnames",
    show_aa_level = "show_aa_level",
    unset_quad_corrections = "unset_quad_corrections"
}
declare class Tools extends PyMuPDFBase {
    static get [Member$4.fitz_config](): PyMuPDFType.Tools.FitzConfig;
    static get [Member$4.store_maxsize](): number;
    static get [Member$4.store_size](): number;
    static [Method$2.gen_id](): number;
    static [Method$2.store_shrink](percent: number): number;
    static [Method$2.mupdf_warnings](reset?: number): number;
    static [Method$2.mupdf_display_errors](on?: boolean): boolean;
    static [Method$2.mupdf_display_warnings](on?: boolean): boolean;
    static [Method$2.reset_mupdf_warnings](): void;
    static [Method$2.set_aa_level](level: number): void;
    static [Method$2.set_annot_stem](stem: string): string;
    static [Method$2.set_small_glyph_heights](on?: boolean): boolean;
    static [Method$2.set_subset_fontnames](on?: boolean): boolean;
    static [Method$2.show_aa_level](): PyMuPDFType.Tools.AntiAliasingLevel;
    static [Method$2.unset_quad_corrections](on?: boolean): boolean;
}

declare const enum Member$3 {
    big_enough = "big_enough",
    filled = "filled",
    more = "more",
    numcalls = "numcalls",
    parameter = "parameter",
    rect = "rect"
}
declare class FitResult extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(...args: unknown[]): PyProxy;
    get [Member$3.big_enough](): boolean;
    get [Member$3.filled](): PyMuPDFType.RectLike;
    get [Member$3.more](): boolean;
    get [Member$3.numcalls](): number;
    get [Member$3.parameter](): number | string;
    get [Member$3.rect](): Rect | IRect;
}

declare const enum Member$2 {
    tagname = "tagname",
    text = "text",
    is_text = "is_text",
    first_child = "first_child",
    last_child = "last_child",
    next = "next",
    previous = "previous",
    root = "root"
}
declare const enum Method$1 {
    add_bullet_list = "add_bullet_list",
    add_codeblock = "add_codeblock",
    add_description_list = "add_description_list",
    add_division = "add_division",
    add_header = "add_header",
    add_horizontal_line = "add_horizontal_line",
    add_image = "add_image",
    add_link = "add_link",
    add_number_list = "add_number_list",
    add_paragraph = "add_paragraph",
    add_span = "add_span",
    add_subscript = "add_subscript",
    add_superscript = "add_superscript",
    add_code = "add_code",
    add_var = "add_var",
    add_samp = "add_samp",
    add_kbd = "add_kbd",
    add_text = "add_text",
    add_style = "add_style",
    add_class = "add_class",
    append_child = "append_child",
    append_styled_span = "append_styled_span",
    bodytag = "bodytag",
    clone = "clone",
    color_text = "color_text",
    create_element = "create_element",
    create_text_node = "create_text_node",
    debug = "debug",
    find = "find",
    find_next = "find_next",
    get_attribute_value = "get_attribute_value",
    get_attributes = "get_attributes",
    insert_after = "insert_after",
    insert_before = "insert_before",
    insert_text = "insert_text",
    remove = "remove",
    remove_attribute = "remove_attribute",
    set_align = "set_align",
    set_attribute = "set_attribute",
    set_bgcolor = "set_bgcolor",
    set_bold = "set_bold",
    set_color = "set_color",
    set_columns = "set_columns",
    set_font = "set_font",
    set_fontsize = "set_fontsize",
    set_id = "set_id",
    set_italic = "set_italic",
    set_leading = "set_leading",
    set_lineheight = "set_lineheight",
    set_margins = "set_margins",
    set_pagebreak_before = "set_pagebreak_before",
    set_word_spacing = "set_word_spacing",
    set_text_indent = "set_text_indent",
    set_letter_spacing = "set_letter_spacing",
    set_opacity = "set_opacity",
    set_underline = "set_underline",
    set_properties = "set_properties",
    span_bottom = "span_bottom"
}
declare class Xml extends PyMuPDFClassBase {
    constructor(ref: PyProxy);
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$2.tagname](): Xml | null;
    get [Member$2.text](): string | null;
    get [Member$2.is_text](): boolean;
    get [Member$2.first_child](): Xml | null;
    get [Member$2.last_child](): Xml | null;
    get [Member$2.next](): Xml | null;
    get [Member$2.previous](): Xml | null;
    get [Member$2.root](): Xml | null;
    [Method$1.add_bullet_list](): Xml;
    [Method$1.add_codeblock](): Xml;
    [Method$1.add_description_list](): Xml;
    [Method$1.add_division](): Xml;
    [Method$1.add_header](level?: number): Xml;
    [Method$1.add_horizontal_line](): Xml;
    [Method$1.add_image](name: string, width?: number, height?: number): Xml;
    [Method$1.add_link](href: string, text?: string): Xml;
    [Method$1.add_number_list](): Xml;
    [Method$1.add_paragraph](): Xml;
    [Method$1.add_span](): Xml;
    [Method$1.add_subscript](text?: string): Xml;
    [Method$1.add_superscript](text?: string): Xml;
    [Method$1.add_code](text?: string): Xml;
    [Method$1.add_var](text?: string): Xml;
    [Method$1.add_samp](text?: string): Xml;
    [Method$1.add_kbd](text?: string): Xml;
    [Method$1.add_text](text: string): Xml;
    [Method$1.append_child](node: Xml): void;
    [Method$1.append_styled_span](style: string): Xml;
    [Method$1.bodytag](): Xml;
    [Method$1.clone](): Xml;
    [Method$1.color_text](color: PyMuPDFType.Color): string;
    [Method$1.create_element](tag: string): Xml;
    [Method$1.create_text_node](text: string): Xml;
    [Method$1.debug](): void;
    [Method$1.find](tag: string, att: string, match: string): Xml | null;
    [Method$1.find_next](tag: string, att: string, match: string): Xml | null;
    [Method$1.get_attribute_value](key: string): string;
    [Method$1.get_attributes](): Record<string, unknown>;
    [Method$1.insert_after](elem: Xml): void;
    [Method$1.insert_before](elem: Xml): void;
    [Method$1.insert_text](text: string): Xml;
    [Method$1.remove](): void;
    [Method$1.remove_attribute](key: string): void;
    [Method$1.set_align](align: string | number): Xml;
    [Method$1.set_attribute](key: string, value?: string): void;
    [Method$1.set_bgcolor](color: PyMuPDFType.Color): Xml;
    [Method$1.set_bold](val?: boolean): Xml;
    [Method$1.set_color](color: PyMuPDFType.Color): Xml;
    [Method$1.set_columns](cols: string | number): Xml;
    [Method$1.set_font](font: string): Xml;
    [Method$1.set_fontsize](fontsize: string | number): Xml;
    [Method$1.set_id](unqid: string): Xml;
    [Method$1.set_italic](val?: boolean): Xml;
    [Method$1.set_leading](leading: number): Xml;
    [Method$1.set_lineheight](lineheight: string | number): Xml;
    [Method$1.set_margins](val: string | number): Xml;
    [Method$1.set_pagebreak_before](): Xml;
    [Method$1.set_word_spacing](spacing: string | number): Xml;
    [Method$1.set_text_indent](indent: string | number): Xml;
    [Method$1.set_letter_spacing](spacing: string | number): Xml;
    [Method$1.set_opacity](opacity: number): Xml;
    [Method$1.set_underline](val?: string): Xml;
    [Method$1.set_properties](options?: PyMuPDFType.Xml.Properties): Xml;
    [Method$1.add_style](text: string): Xml;
    [Method$1.add_class](text: string): Xml;
}

declare const enum Member$1 {
    body = "body"
}
declare const enum Method {
    reset = "reset",
    place = "place",
    draw = "draw",
    element_positions = "element_positions",
    write = "write",
    write_stabilized = "write_stabilized",
    write_with_links = "write_with_links",
    write_stabilized_with_links = "write_stabilized_with_links",
    fit = "fit",
    fit_scale = "fit_scale",
    fit_height = "fit_height",
    fit_width = "fit_width",
    add_header_ids = "add_header_ids",
    add_pdf_links = "add_pdf_links",
    document = "document"
}
declare class Story extends PyMuPDFClassBase {
    constructor();
    constructor(html: string | null);
    constructor(html: string | null, user_css: string | null);
    constructor(html: string | null, user_css: string | null, em: number);
    constructor(html: string | null, user_css: string | null, em: number, archive: Archive);
    constructor(ref: PyProxy);
    protected buildOrigin(): PyProxy;
    protected buildOrigin(html: string | null): PyProxy;
    protected buildOrigin(html: string | null, user_css: string | null): PyProxy;
    protected buildOrigin(html: string | null, user_css: string | null, em: number): PyProxy;
    protected buildOrigin(html: string | null, user_css: string | null, em: number, archive: Archive | null): PyProxy;
    protected buildOrigin(ref: PyProxy): PyProxy;
    get [Member$1.body](): Xml;
    [Method.reset](): void;
    [Method.place](where: PyMuPDFType.RectLike | Rect): [more: boolean, filled: PyMuPDFType.RectLike];
    [Method.draw](dev: DeviceWrapper, matrix?: PyMuPDFType.MatrixLike | Matrix): void;
    [Method.element_positions](func: (pos: Position2) => void, args?: Record<string, unknown>): void;
    [Method.write](writer: DocumentWriter | null, rectfn: (rect_num: number, filled: Rect) => [mediabox: Rect | null, rect: Rect, ctm: Matrix | null], positionfn?: (pos: Position2) => void, pagefn?: (page_num: number, mediabox: Rect, dev: DeviceWrapper | null, after: 0 | 1) => void): void;
    static [Method.write_stabilized](writer: DocumentWriter, contentfn: (pos: Position2[]) => string, rectfn: (rect_num: number, filled: Rect) => [mediabox: Rect | null, rect: Rect, ctm: Matrix | null], options?: PyMuPDFType.Story.WriteStabilizedOptions & {
        archive?: Archive;
    }): void;
    static [Method.write_stabilized_with_links](contentfn: (pos: Position2[]) => string, rectfn: (rect_num: number, filled: Rect) => [mediabox: Rect | null, rect: Rect, ctm: Matrix | null], options?: PyMuPDFType.Story.WriteStabilizedOptions & {
        archive?: Archive;
    }): Document$1;
    [Method.write_with_links](rectfn: (rect_num: number, filled: Rect) => [mediabox: Rect | null, rect: Rect, ctm: Matrix | null], positionfn?: (pos: Position2) => void, pagefn?: (page_num: number, mediabox: Rect, dev: DeviceWrapper | null, after: 0 | 1) => void): Document$1;
    [Method.fit](fn: (param: number) => Rect, pmin?: number, pmax?: number, delta?: number, verbose?: boolean): FitResult;
    [Method.fit_scale](rect: IRect | Rect, scale_min?: number, scale_max?: number, delta?: number, verbose?: boolean): FitResult;
    [Method.fit_height](width: number, height_min?: number, height_max?: number, origin?: PyMuPDFType.PointLike, delta?: number, verbose?: boolean): FitResult;
    [Method.fit_width](height: number, width_min?: number, width_max?: number, origin?: PyMuPDFType.PointLike, delta?: number): FitResult;
    [Method.add_header_ids](): void;
    static [Method.add_pdf_links](document_or_stream: Document$1 | ArrayBuffer, positions: Position2[]): Document$1;
    [Method.document](): Xml;
}

declare const enum Member {
    Identity = "Identity",
    pdfcolor = "pdfcolor",
    csRGB = "csRGB",
    csGRAY = "csGRAY",
    csCMYK = "csCMYK",
    CS_RGB = "CS_RGB",
    CS_GRAY = "CS_GRAY",
    CS_CMYK = "CS_CMYK",
    mupdf_version = "mupdf_version",
    mupdf_version_tuple = "mupdf_version_tuple",
    pymupdf_version = "pymupdf_version",
    pymupdf_version_tuple = "pymupdf_version_tuple",
    pymupdf_date = "pymupdf_date",
    version = "version",
    PDF_PERM_PRINT = "PDF_PERM_PRINT",
    PDF_PERM_MODIFY = "PDF_PERM_MODIFY",
    PDF_PERM_COPY = "PDF_PERM_COPY",
    PDF_PERM_ANNOTATE = "PDF_PERM_ANNOTATE",
    PDF_PERM_FORM = "PDF_PERM_FORM",
    PDF_PERM_ACCESSIBILITY = "PDF_PERM_ACCESSIBILITY",
    PDF_PERM_ASSEMBLE = "PDF_PERM_ASSEMBLE",
    PDF_PERM_PRINT_HQ = "PDF_PERM_PRINT_HQ",
    PDF_OC_ON = "PDF_OC_ON",
    PDF_OC_TOGGLE = "PDF_OC_TOGGLE",
    PDF_OC_OFF = "PDF_OC_OFF",
    PDF_ENCRYPT_KEEP = "PDF_ENCRYPT_KEEP",
    PDF_ENCRYPT_NONE = "PDF_ENCRYPT_NONE",
    PDF_ENCRYPT_RC4_40 = "PDF_ENCRYPT_RC4_40",
    PDF_ENCRYPT_RC4_128 = "PDF_ENCRYPT_RC4_128",
    PDF_ENCRYPT_AES_128 = "PDF_ENCRYPT_AES_128",
    PDF_ENCRYPT_AES_256 = "PDF_ENCRYPT_AES_256",
    PDF_ENCRYPT_UNKNOWN = "PDF_ENCRYPT_UNKNOWN",
    TEXT_ALIGN_LEFT = "TEXT_ALIGN_LEFT",
    TEXT_ALIGN_CENTER = "TEXT_ALIGN_CENTER",
    TEXT_ALIGN_RIGHT = "TEXT_ALIGN_RIGHT",
    TEXT_ALIGN_JUSTIFY = "TEXT_ALIGN_JUSTIFY",
    TEXT_FONT_SUPERSCRIPT = "TEXT_FONT_SUPERSCRIPT",
    TEXT_FONT_ITALIC = "TEXT_FONT_ITALIC",
    TEXT_FONT_SERIFED = "TEXT_FONT_SERIFED",
    TEXT_FONT_MONOSPACED = "TEXT_FONT_MONOSPACED",
    TEXT_FONT_BOLD = "TEXT_FONT_BOLD",
    TEXT_PRESERVE_LIGATURES = "TEXT_PRESERVE_LIGATURES",
    TEXT_PRESERVE_WHITESPACE = "TEXT_PRESERVE_WHITESPACE",
    TEXT_PRESERVE_IMAGES = "TEXT_PRESERVE_IMAGES",
    TEXT_INHIBIT_SPACES = "TEXT_INHIBIT_SPACES",
    TEXT_DEHYPHENATE = "TEXT_DEHYPHENATE",
    TEXT_PRESERVE_SPANS = "TEXT_PRESERVE_SPANS",
    TEXT_MEDIABOX_CLIP = "TEXT_MEDIABOX_CLIP",
    TEXT_USE_CID_FOR_UNKNOWN_UNICODE = "TEXT_USE_CID_FOR_UNKNOWN_UNICODE",
    TEXT_COLLECT_STRUCTURE = "TEXT_COLLECT_STRUCTURE",
    TEXT_ACCURATE_BBOXES = "TEXT_ACCURATE_BBOXES",
    TEXT_COLLECT_VECTORS = "TEXT_COLLECT_VECTORS",
    TEXT_IGNORE_ACTUALTEXT = "TEXT_IGNORE_ACTUALTEXT",
    TEXT_SEGMENT = "TEXT_SEGMENT",
    TEXTFLAGS_TEXT = "TEXTFLAGS_TEXT",
    TEXTFLAGS_WORDS = "TEXTFLAGS_WORDS",
    TEXTFLAGS_BLOCKS = "TEXTFLAGS_BLOCKS",
    TEXTFLAGS_DICT = "TEXTFLAGS_DICT",
    TEXTFLAGS_RAWDICT = "TEXTFLAGS_RAWDICT",
    TEXTFLAGS_HTML = "TEXTFLAGS_HTML",
    TEXTFLAGS_XHTML = "TEXTFLAGS_XHTML",
    TEXTFLAGS_XML = "TEXTFLAGS_XML",
    TEXTFLAGS_SEARCH = "TEXTFLAGS_SEARCH",
    LINK_NONE = "LINK_NONE",
    LINK_GOTO = "LINK_GOTO",
    LINK_URI = "LINK_URI",
    LINK_LAUNCH = "LINK_LAUNCH",
    LINK_NAMED = "LINK_NAMED",
    LINK_GOTOR = "LINK_GOTOR",
    LINK_FLAG_L_VALID = "LINK_FLAG_L_VALID",
    LINK_FLAG_T_VALID = "LINK_FLAG_T_VALID",
    LINK_FLAG_R_VALID = "LINK_FLAG_R_VALID",
    LINK_FLAG_B_VALID = "LINK_FLAG_B_VALID",
    LINK_FLAG_FIT_H = "LINK_FLAG_FIT_H",
    LINK_FLAG_FIT_V = "LINK_FLAG_FIT_V",
    LINK_FLAG_R_IS_ZOOM = "LINK_FLAG_R_IS_ZOOM",
    PDF_ANNOT_TEXT = "PDF_ANNOT_TEXT",
    PDF_ANNOT_LINK = "PDF_ANNOT_LINK",
    PDF_ANNOT_FREE_TEXT = "PDF_ANNOT_FREE_TEXT",
    PDF_ANNOT_LINE = "PDF_ANNOT_LINE",
    PDF_ANNOT_SQUARE = "PDF_ANNOT_SQUARE",
    PDF_ANNOT_CIRCLE = "PDF_ANNOT_CIRCLE",
    PDF_ANNOT_POLYGON = "PDF_ANNOT_POLYGON",
    PDF_ANNOT_POLY_LINE = "PDF_ANNOT_POLY_LINE",
    PDF_ANNOT_HIGHLIGHT = "PDF_ANNOT_HIGHLIGHT",
    PDF_ANNOT_UNDERLINE = "PDF_ANNOT_UNDERLINE",
    PDF_ANNOT_SQUIGGLY = "PDF_ANNOT_SQUIGGLY",
    PDF_ANNOT_STRIKE_OUT = "PDF_ANNOT_STRIKE_OUT",
    PDF_ANNOT_REDACT = "PDF_ANNOT_REDACT",
    PDF_ANNOT_STAMP = "PDF_ANNOT_STAMP",
    PDF_ANNOT_CARET = "PDF_ANNOT_CARET",
    PDF_ANNOT_INK = "PDF_ANNOT_INK",
    PDF_ANNOT_POPUP = "PDF_ANNOT_POPUP",
    PDF_ANNOT_FILE_ATTACHMENT = "PDF_ANNOT_FILE_ATTACHMENT",
    PDF_ANNOT_SOUND = "PDF_ANNOT_SOUND",
    PDF_ANNOT_MOVIE = "PDF_ANNOT_MOVIE",
    PDF_ANNOT_RICH_MEDIA = "PDF_ANNOT_RICH_MEDIA",
    PDF_ANNOT_WIDGET = "PDF_ANNOT_WIDGET",
    PDF_ANNOT_SCREEN = "PDF_ANNOT_SCREEN",
    PDF_ANNOT_PRINTER_MARK = "PDF_ANNOT_PRINTER_MARK",
    PDF_ANNOT_TRAP_NET = "PDF_ANNOT_TRAP_NET",
    PDF_ANNOT_WATERMARK = "PDF_ANNOT_WATERMARK",
    PDF_ANNOT_3D = "PDF_ANNOT_3D",
    PDF_ANNOT_PROJECTION = "PDF_ANNOT_PROJECTION",
    PDF_ANNOT_UNKNOWN = "PDF_ANNOT_UNKNOWN",
    PDF_ANNOT_IS_INVISIBLE = "PDF_ANNOT_IS_INVISIBLE",
    PDF_ANNOT_IS_HIDDEN = "PDF_ANNOT_IS_HIDDEN",
    PDF_ANNOT_IS_PRINT = "PDF_ANNOT_IS_PRINT",
    PDF_ANNOT_IS_NO_ZOOM = "PDF_ANNOT_IS_NO_ZOOM",
    PDF_ANNOT_IS_NO_ROTATE = "PDF_ANNOT_IS_NO_ROTATE",
    PDF_ANNOT_IS_NO_VIEW = "PDF_ANNOT_IS_NO_VIEW",
    PDF_ANNOT_IS_READ_ONLY = "PDF_ANNOT_IS_READ_ONLY",
    PDF_ANNOT_IS_LOCKED = "PDF_ANNOT_IS_LOCKED",
    PDF_ANNOT_IS_TOGGLE_NO_VIEW = "PDF_ANNOT_IS_TOGGLE_NO_VIEW",
    PDF_ANNOT_IS_LOCKED_CONTENTS = "PDF_ANNOT_IS_LOCKED_CONTENTS",
    PDF_ANNOT_LE_NONE = "PDF_ANNOT_LE_NONE",
    PDF_ANNOT_LE_SQUARE = "PDF_ANNOT_LE_SQUARE",
    PDF_ANNOT_LE_CIRCLE = "PDF_ANNOT_LE_CIRCLE",
    PDF_ANNOT_LE_DIAMOND = "PDF_ANNOT_LE_DIAMOND",
    PDF_ANNOT_LE_OPEN_ARROW = "PDF_ANNOT_LE_OPEN_ARROW",
    PDF_ANNOT_LE_CLOSED_ARROW = "PDF_ANNOT_LE_CLOSED_ARROW",
    PDF_ANNOT_LE_BUTT = "PDF_ANNOT_LE_BUTT",
    PDF_ANNOT_LE_R_OPEN_ARROW = "PDF_ANNOT_LE_R_OPEN_ARROW",
    PDF_ANNOT_LE_R_CLOSED_ARROW = "PDF_ANNOT_LE_R_CLOSED_ARROW",
    PDF_ANNOT_LE_SLASH = "PDF_ANNOT_LE_SLASH",
    PDF_WIDGET_TYPE_UNKNOWN = "PDF_WIDGET_TYPE_UNKNOWN",
    PDF_WIDGET_TYPE_BUTTON = "PDF_WIDGET_TYPE_BUTTON",
    PDF_WIDGET_TYPE_CHECKBOX = "PDF_WIDGET_TYPE_CHECKBOX",
    PDF_WIDGET_TYPE_COMBOBOX = "PDF_WIDGET_TYPE_COMBOBOX",
    PDF_WIDGET_TYPE_LISTBOX = "PDF_WIDGET_TYPE_LISTBOX",
    PDF_WIDGET_TYPE_RADIOBUTTON = "PDF_WIDGET_TYPE_RADIOBUTTON",
    PDF_WIDGET_TYPE_SIGNATURE = "PDF_WIDGET_TYPE_SIGNATURE",
    PDF_WIDGET_TYPE_TEXT = "PDF_WIDGET_TYPE_TEXT",
    PDF_WIDGET_TX_FORMAT_NONE = "PDF_WIDGET_TX_FORMAT_NONE",
    PDF_WIDGET_TX_FORMAT_NUMBER = "PDF_WIDGET_TX_FORMAT_NUMBER",
    PDF_WIDGET_TX_FORMAT_SPECIAL = "PDF_WIDGET_TX_FORMAT_SPECIAL",
    PDF_WIDGET_TX_FORMAT_DATE = "PDF_WIDGET_TX_FORMAT_DATE",
    PDF_WIDGET_TX_FORMAT_TIME = "PDF_WIDGET_TX_FORMAT_TIME",
    PDF_FIELD_IS_READ_ONLY = "PDF_FIELD_IS_READ_ONLY",
    PDF_FIELD_IS_REQUIRED = "PDF_FIELD_IS_REQUIRED",
    PDF_FIELD_IS_NO_EXPORT = "PDF_FIELD_IS_NO_EXPORT",
    PDF_TX_FIELD_IS_MULTILINE = "PDF_TX_FIELD_IS_MULTILINE",
    PDF_TX_FIELD_IS_PASSWORD = "PDF_TX_FIELD_IS_PASSWORD",
    PDF_TX_FIELD_IS_FILE_SELECT = "PDF_TX_FIELD_IS_FILE_SELECT",
    PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK = "PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK",
    PDF_TX_FIELD_IS_DO_NOT_SCROLL = "PDF_TX_FIELD_IS_DO_NOT_SCROLL",
    PDF_TX_FIELD_IS_COMB = "PDF_TX_FIELD_IS_COMB",
    PDF_TX_FIELD_IS_RICH_TEXT = "PDF_TX_FIELD_IS_RICH_TEXT",
    PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF = "PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF",
    PDF_BTN_FIELD_IS_RADIO = "PDF_BTN_FIELD_IS_RADIO",
    PDF_BTN_FIELD_IS_PUSHBUTTON = "PDF_BTN_FIELD_IS_PUSHBUTTON",
    PDF_BTN_FIELD_IS_RADIOS_IN_UNISON = "PDF_BTN_FIELD_IS_RADIOS_IN_UNISON",
    PDF_CH_FIELD_IS_COMBO = "PDF_CH_FIELD_IS_COMBO",
    PDF_CH_FIELD_IS_EDIT = "PDF_CH_FIELD_IS_EDIT",
    PDF_CH_FIELD_IS_SORT = "PDF_CH_FIELD_IS_SORT",
    PDF_CH_FIELD_IS_MULTI_SELECT = "PDF_CH_FIELD_IS_MULTI_SELECT",
    PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK = "PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK",
    PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE = "PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE",
    PDF_BM_Color = "PDF_BM_Color",
    PDF_BM_ColorBurn = "PDF_BM_ColorBurn",
    PDF_BM_ColorDodge = "PDF_BM_ColorDodge",
    PDF_BM_Darken = "PDF_BM_Darken",
    PDF_BM_Difference = "PDF_BM_Difference",
    PDF_BM_Exclusion = "PDF_BM_Exclusion",
    PDF_BM_HardLight = "PDF_BM_HardLight",
    PDF_BM_Hue = "PDF_BM_Hue",
    PDF_BM_Lighten = "PDF_BM_Lighten",
    PDF_BM_Luminosity = "PDF_BM_Luminosity",
    PDF_BM_Multiply = "PDF_BM_Multiply",
    PDF_BM_Normal = "PDF_BM_Normal",
    PDF_BM_Overlay = "PDF_BM_Overlay",
    PDF_BM_Saturation = "PDF_BM_Saturation",
    PDF_BM_Screen = "PDF_BM_Screen",
    PDF_BM_SoftLight = "PDF_BM_SoftLight",
    STAMP_Approved = "STAMP_Approved",
    STAMP_AsIs = "STAMP_AsIs",
    STAMP_Confidential = "STAMP_Confidential",
    STAMP_Departmental = "STAMP_Departmental",
    STAMP_Experimental = "STAMP_Experimental",
    STAMP_Expired = "STAMP_Expired",
    STAMP_Final = "STAMP_Final",
    STAMP_ForComment = "STAMP_ForComment",
    STAMP_ForPublicRelease = "STAMP_ForPublicRelease",
    STAMP_NotApproved = "STAMP_NotApproved",
    STAMP_NotForPublicRelease = "STAMP_NotForPublicRelease",
    STAMP_Sold = "STAMP_Sold",
    STAMP_TopSecret = "STAMP_TopSecret",
    STAMP_Draft = "STAMP_Draft"
}
declare class Constant extends PyMuPDFBase {
    get [Member.Identity](): Matrix;
    get [Member.pdfcolor](): PyMuPDFType.PDFColor;
    get [Member.csRGB](): Colorspace;
    get [Member.csGRAY](): Colorspace;
    get [Member.csCMYK](): Colorspace;
    get [Member.CS_RGB](): number;
    get [Member.CS_GRAY](): number;
    get [Member.CS_CMYK](): number;
    get [Member.mupdf_version](): string;
    get [Member.mupdf_version_tuple](): PyMuPDFType.Version;
    get [Member.pymupdf_version](): string;
    get [Member.pymupdf_version_tuple](): PyMuPDFType.Version;
    get [Member.pymupdf_date](): string;
    get [Member.version](): PyMuPDFType.AllVersion;
    get [Member.PDF_PERM_PRINT](): number;
    get [Member.PDF_PERM_MODIFY](): number;
    get [Member.PDF_PERM_COPY](): number;
    get [Member.PDF_PERM_ANNOTATE](): number;
    get [Member.PDF_PERM_FORM](): number;
    get [Member.PDF_PERM_ACCESSIBILITY](): number;
    get [Member.PDF_PERM_ASSEMBLE](): number;
    get [Member.PDF_PERM_PRINT_HQ](): number;
    get [Member.PDF_OC_ON](): number;
    get [Member.PDF_OC_TOGGLE](): number;
    get [Member.PDF_OC_OFF](): number;
    get [Member.PDF_ENCRYPT_KEEP](): number;
    get [Member.PDF_ENCRYPT_NONE](): number;
    get [Member.PDF_ENCRYPT_RC4_40](): number;
    get [Member.PDF_ENCRYPT_RC4_128](): number;
    get [Member.PDF_ENCRYPT_AES_128](): number;
    get [Member.PDF_ENCRYPT_AES_256](): number;
    get [Member.PDF_ENCRYPT_UNKNOWN](): number;
    get [Member.TEXT_ALIGN_LEFT](): number;
    get [Member.TEXT_ALIGN_CENTER](): number;
    get [Member.TEXT_ALIGN_RIGHT](): number;
    get [Member.TEXT_ALIGN_JUSTIFY](): number;
    get [Member.TEXT_FONT_SUPERSCRIPT](): number;
    get [Member.TEXT_FONT_ITALIC](): number;
    get [Member.TEXT_FONT_SERIFED](): number;
    get [Member.TEXT_FONT_MONOSPACED](): number;
    get [Member.TEXT_FONT_BOLD](): number;
    get [Member.TEXT_PRESERVE_LIGATURES](): number;
    get [Member.TEXT_PRESERVE_WHITESPACE](): number;
    get [Member.TEXT_PRESERVE_IMAGES](): number;
    get [Member.TEXT_INHIBIT_SPACES](): number;
    get [Member.TEXT_DEHYPHENATE](): number;
    get [Member.TEXT_PRESERVE_SPANS](): number;
    get [Member.TEXT_MEDIABOX_CLIP](): number;
    get [Member.TEXT_USE_CID_FOR_UNKNOWN_UNICODE](): number;
    get [Member.TEXT_COLLECT_STRUCTURE](): number;
    get [Member.TEXT_ACCURATE_BBOXES](): number;
    get [Member.TEXT_COLLECT_VECTORS](): number;
    get [Member.TEXT_IGNORE_ACTUALTEXT](): number;
    get [Member.TEXT_SEGMENT](): number;
    get [Member.TEXTFLAGS_TEXT](): number;
    get [Member.TEXTFLAGS_WORDS](): number;
    get [Member.TEXTFLAGS_BLOCKS](): number;
    get [Member.TEXTFLAGS_DICT](): number;
    get [Member.TEXTFLAGS_RAWDICT](): number;
    get [Member.TEXTFLAGS_HTML](): number;
    get [Member.TEXTFLAGS_XHTML](): number;
    get [Member.TEXTFLAGS_XML](): number;
    get [Member.TEXTFLAGS_SEARCH](): number;
    get [Member.LINK_NONE](): number;
    get [Member.LINK_GOTO](): number;
    get [Member.LINK_URI](): number;
    get [Member.LINK_LAUNCH](): number;
    get [Member.LINK_NAMED](): number;
    get [Member.LINK_GOTOR](): number;
    get [Member.LINK_FLAG_L_VALID](): number;
    get [Member.LINK_FLAG_T_VALID](): number;
    get [Member.LINK_FLAG_R_VALID](): number;
    get [Member.LINK_FLAG_B_VALID](): number;
    get [Member.LINK_FLAG_FIT_H](): number;
    get [Member.LINK_FLAG_FIT_V](): number;
    get [Member.LINK_FLAG_R_IS_ZOOM](): number;
    get [Member.PDF_ANNOT_TEXT](): number;
    get [Member.PDF_ANNOT_LINK](): number;
    get [Member.PDF_ANNOT_FREE_TEXT](): number;
    get [Member.PDF_ANNOT_LINE](): number;
    get [Member.PDF_ANNOT_SQUARE](): number;
    get [Member.PDF_ANNOT_CIRCLE](): number;
    get [Member.PDF_ANNOT_POLYGON](): number;
    get [Member.PDF_ANNOT_POLY_LINE](): number;
    get [Member.PDF_ANNOT_HIGHLIGHT](): number;
    get [Member.PDF_ANNOT_UNDERLINE](): number;
    get [Member.PDF_ANNOT_SQUIGGLY](): number;
    get [Member.PDF_ANNOT_STRIKE_OUT](): number;
    get [Member.PDF_ANNOT_REDACT](): number;
    get [Member.PDF_ANNOT_STAMP](): number;
    get [Member.PDF_ANNOT_CARET](): number;
    get [Member.PDF_ANNOT_INK](): number;
    get [Member.PDF_ANNOT_POPUP](): number;
    get [Member.PDF_ANNOT_FILE_ATTACHMENT](): number;
    get [Member.PDF_ANNOT_SOUND](): number;
    get [Member.PDF_ANNOT_MOVIE](): number;
    get [Member.PDF_ANNOT_RICH_MEDIA](): number;
    get [Member.PDF_ANNOT_WIDGET](): number;
    get [Member.PDF_ANNOT_SCREEN](): number;
    get [Member.PDF_ANNOT_PRINTER_MARK](): number;
    get [Member.PDF_ANNOT_TRAP_NET](): number;
    get [Member.PDF_ANNOT_WATERMARK](): number;
    get [Member.PDF_ANNOT_3D](): number;
    get [Member.PDF_ANNOT_PROJECTION](): number;
    get [Member.PDF_ANNOT_UNKNOWN](): number;
    get [Member.PDF_ANNOT_IS_INVISIBLE](): number;
    get [Member.PDF_ANNOT_IS_HIDDEN](): number;
    get [Member.PDF_ANNOT_IS_PRINT](): number;
    get [Member.PDF_ANNOT_IS_NO_ZOOM](): number;
    get [Member.PDF_ANNOT_IS_NO_ROTATE](): number;
    get [Member.PDF_ANNOT_IS_NO_VIEW](): number;
    get [Member.PDF_ANNOT_IS_READ_ONLY](): number;
    get [Member.PDF_ANNOT_IS_LOCKED](): number;
    get [Member.PDF_ANNOT_IS_TOGGLE_NO_VIEW](): number;
    get [Member.PDF_ANNOT_IS_LOCKED_CONTENTS](): number;
    get [Member.PDF_ANNOT_LE_NONE](): number;
    get [Member.PDF_ANNOT_LE_SQUARE](): number;
    get [Member.PDF_ANNOT_LE_CIRCLE](): number;
    get [Member.PDF_ANNOT_LE_DIAMOND](): number;
    get [Member.PDF_ANNOT_LE_OPEN_ARROW](): number;
    get [Member.PDF_ANNOT_LE_CLOSED_ARROW](): number;
    get [Member.PDF_ANNOT_LE_BUTT](): number;
    get [Member.PDF_ANNOT_LE_R_OPEN_ARROW](): number;
    get [Member.PDF_ANNOT_LE_R_CLOSED_ARROW](): number;
    get [Member.PDF_ANNOT_LE_SLASH](): number;
    get [Member.PDF_WIDGET_TYPE_UNKNOWN](): number;
    get [Member.PDF_WIDGET_TYPE_BUTTON](): number;
    get [Member.PDF_WIDGET_TYPE_CHECKBOX](): number;
    get [Member.PDF_WIDGET_TYPE_COMBOBOX](): number;
    get [Member.PDF_WIDGET_TYPE_LISTBOX](): number;
    get [Member.PDF_WIDGET_TYPE_RADIOBUTTON](): number;
    get [Member.PDF_WIDGET_TYPE_SIGNATURE](): number;
    get [Member.PDF_WIDGET_TYPE_TEXT](): number;
    get [Member.PDF_WIDGET_TX_FORMAT_NONE](): number;
    get [Member.PDF_WIDGET_TX_FORMAT_NUMBER](): number;
    get [Member.PDF_WIDGET_TX_FORMAT_SPECIAL](): number;
    get [Member.PDF_WIDGET_TX_FORMAT_DATE](): number;
    get [Member.PDF_WIDGET_TX_FORMAT_TIME](): number;
    get [Member.PDF_FIELD_IS_READ_ONLY](): number;
    get [Member.PDF_FIELD_IS_REQUIRED](): number;
    get [Member.PDF_FIELD_IS_NO_EXPORT](): number;
    get [Member.PDF_TX_FIELD_IS_MULTILINE](): number;
    get [Member.PDF_TX_FIELD_IS_PASSWORD](): number;
    get [Member.PDF_TX_FIELD_IS_FILE_SELECT](): number;
    get [Member.PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK](): number;
    get [Member.PDF_TX_FIELD_IS_COMB](): number;
    get [Member.PDF_TX_FIELD_IS_RICH_TEXT](): number;
    get [Member.PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF](): number;
    get [Member.PDF_BTN_FIELD_IS_RADIO](): number;
    get [Member.PDF_BTN_FIELD_IS_PUSHBUTTON](): number;
    get [Member.PDF_BTN_FIELD_IS_RADIOS_IN_UNISON](): number;
    get [Member.PDF_CH_FIELD_IS_COMBO](): number;
    get [Member.PDF_CH_FIELD_IS_EDIT](): number;
    get [Member.PDF_CH_FIELD_IS_SORT](): number;
    get [Member.PDF_CH_FIELD_IS_MULTI_SELECT](): number;
    get [Member.PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK](): number;
    get [Member.PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE](): number;
    get [Member.PDF_BM_Color](): string;
    get [Member.PDF_BM_ColorBurn](): string;
    get [Member.PDF_BM_ColorDodge](): string;
    get [Member.PDF_BM_Darken](): string;
    get [Member.PDF_BM_Difference](): string;
    get [Member.PDF_BM_Exclusion](): string;
    get [Member.PDF_BM_HardLight](): string;
    get [Member.PDF_BM_Hue](): string;
    get [Member.PDF_BM_Lighten](): string;
    get [Member.PDF_BM_Luminosity](): string;
    get [Member.PDF_BM_Multiply](): string;
    get [Member.PDF_BM_Normal](): string;
    get [Member.PDF_BM_Overlay](): string;
    get [Member.PDF_BM_Saturation](): string;
    get [Member.PDF_BM_Screen](): string;
    get [Member.PDF_BM_SoftLight](): string;
    get [Member.STAMP_Approved](): number;
    get [Member.STAMP_AsIs](): number;
    get [Member.STAMP_Confidential](): number;
    get [Member.STAMP_Departmental](): number;
    get [Member.STAMP_Experimental](): number;
    get [Member.STAMP_Expired](): number;
    get [Member.STAMP_Final](): number;
    get [Member.STAMP_ForComment](): number;
    get [Member.STAMP_ForPublicRelease](): number;
    get [Member.STAMP_NotApproved](): number;
    get [Member.STAMP_NotForPublicRelease](): number;
    get [Member.STAMP_Sold](): number;
    get [Member.STAMP_TopSecret](): number;
    get [Member.STAMP_Draft](): number;
}

declare function loadPyMuPDF(pymupdfWheel: string): Promise<PyMuPDF>;
declare function loadPyMuPDF4LLM(wheel: string): Promise<PyMuPDF4LLM>;
declare function loadPillow(): Promise<void>;
declare const enum PyMuPDFMethod {
    open = "open",
    sRGB_to_pdf = "sRGB_to_pdf"
}
declare class PyMuPDF extends PyMuPDFBase {
    Document: typeof Document$1;
    Matrix: typeof Matrix;
    Rect: typeof Rect;
    Point: typeof Point;
    Quad: typeof Quad;
    Colorspace: typeof Colorspace;
    Widget: typeof Widget;
    Pixmap: typeof Pixmap;
    IRect: typeof IRect;
    Archive: typeof Archive;
    DisplayList: typeof DisplayList;
    DeviceWrapper: typeof DeviceWrapper;
    DocumentWriter: typeof DocumentWriter;
    Tools: typeof Tools;
    Story: typeof Story;
    TextWriter: typeof TextWriter;
    Font: typeof Font;
    Shape: typeof Shape;
    readonly Constant: Constant;
    [PyMuPDFMethod.open](filename?: string | null): Document$1;
    [PyMuPDFMethod.sRGB_to_pdf](srgb: number): PyMuPDFType.ColorSequence;
}
declare class PyMuPDF4LLM extends PyMuPDFBase {
    IdentifyHeaders: typeof IdentifyHeaders;
    TocHeaders: typeof TocHeaders;
    to_markdown(doc: Document$1): string;
    to_markdown(doc: Document$1, options: {
        extract_words: true;
    } & PyMuPDF4LLMType.ToMarkdownOptions): PyMuPDF4LLMType.ToMarkdownResult[];
    to_markdown(doc: Document$1, options: {
        extract_words: false;
    } & PyMuPDF4LLMType.ToMarkdownOptions): string;
}

export { Annot, Archive, Colorspace, Constant, DeviceWrapper, DisplayList, Document$1 as Document, DocumentWriter, FitResult, Font, Geometry, IRect, IdentifyHeaders, Link, Matrix, Outline, Page, PillowImage, Pixmap, Point, Position2, Quad, Rect, Shape, Story, Table, TableFinder, TableHeader, TableRow, TextPage, TextWriter, TocHeaders, Tools, Widget, Xml, linkDest, loadPillow, loadPyMuPDF, loadPyMuPDF4LLM };
